## 리스트의 개념 <br>
리스트란 자료를 순서대로 저장하는 자료구조를 의미한다. -> 구조가 단순함.<br>
이때 여러 자료들은 서로 선형으로 연결되어있는 구조다. <앞뒤 관계가 1:1><br>
![링크드리스트](https://user-images.githubusercontent.com/43705434/108394195-cd7a5600-7257-11eb-9f94-16ebe2241ae5.png)
<br>

## Array List <br>
간단하게 설명하자면 배열의 발전된 형태로,크기를 조정할 수 있는 배열 정도로 생각해도 좋다.<br>

**장점 : 배열을 이용해 만든 리스트이기 때문에, 인덱스를 통해 빠른 검색 연산이 가능하며, 구현이 간단하다.**<br>

**단점 : 배열의 크기를 가변적으로 사용할 수 있지만, 기존의 데이터를 전부 복사해야하기에 연산적으로 비효율적이다.<br>
또한, 데이터 추가, 삭제 시 원소의 이동이 빈번하기 때문에 연산이 많이 들며, 느리다.**<br>
<br>

**구현 Tip.**<br>
1. 배열리스트의 메모리를 동적으로 늘리기 위해서는 realloc을 사용하면 된다.<br>
<br>

## Array vs Array List (배열을 이용해 구현한 리스트)<br> 
애초에 배열 vs 배열로 구현한 리스트 이기 때문에 비교선상에 놓기에는 어색한 감이 있지만 굳이 비교 해보겠다.<br> 
* 중간에있는 데이터가 삭제되었을때, 배열리스트는 선형적으로 모든 데이터가 연결되어있어야 하기 때문에,<br> 
해당 빈공간만큼 앞으로 앞당겨줘 연결시켜줘야한다. 또한 추가할때에는 뒤로 밀어줘야한다.<br>

> 배열은 중간에 데이터를 삽입, 삭제 한다는 개념이 아니라 그저 overwrite 일 뿐이다.<br>
<br>

* 배열리스트는 동적으로 메모리를 늘리고 줄일 수 있다. 하지만 배열은 정적으로 런타임중 메모리를 변경할 수 없다.<br>
<br>

* 배열리스트는 데이터 추가, 삭제 시 기존 데이터들을 밀고 당겨줘야 하며, 메모리 부족 시 realloc을 하기도 하기 때문에<br>
배열보다 연산 속도가 느리다.<br>
<br>

## Linked List<br> 
링크드 리스트는 포인터의 개념을 이용해서, 메모리에 불연속적으로 존재하는 데이터들을 순서대로 연결시켜 선형적인<br>
자료구조로 만든 것이다. 메모리가 논리적으로 즉 물리적으로 순차적이지 않게 잡혀있다.<br>
-> 고로 링크드리스트는 최대원소개수 지정이 필요없다!<br>
> Node = 데이터 + 링크
<br>

**장점 : 링크드리스트는 포인터를 이용하기때문에 크기가 제한되지 않으며, 불연속적으로 메모리 공간을 차지 할 수 있어<br> 
메모리의 관리 및 재사용이 편리하다. 또한 원소를 중간에 삽입, 삭제 하는 것이 용이하다**<br>

**단점 : 포인터를 이용하기 때문에, 다음 데이터를 가르킬 추가적인 메모리 공간이 발생된다<br>
또한 헤더 포인터부터 순차적으로 순회해야 하기 때문에 검색 성능이 좋지 않다.**<br>
<br>

**구현 Tip.**<br>
1. 노드 구조체는 데이터와 다음 노드를 가리킬 노드 포인터를 가져야 한다. (자기 참조 구조체)<br>
2. 링크드리스트 구조체는 리스트의 시작을 알릴 헤더 포인터를 가져야 한다.<br>
<br>

## Linked List의 종류 <br>
단순 연결 리스트 -> -> -> -><br>
원형 연결 리스트 -> -> -> -> 첫번째<br>
이중 연결 리스트 -> -> -> -><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<- <- <- <-<br>

![리스트](https://user-images.githubusercontent.com/43705434/108394199-ce12ec80-7257-11eb-8e0f-a4376148c619.png)

- Previous 노드에 대한 접근?<br>
단순연결리스트는 이전 노드에 접근이 불가능<br>
원형연결리스트는 계속 돌다보면 다시 처음부터 돌기때문에 접근가능<br>
이중연결리스트는 양방향이기에 바로 접근가능<br>
<br>

### Array List vs Linked List<br>
데이터의 크기가 정해져있지 않고, 삽입 삭제가 많이 일어나며 검색이 적은 경우에는 링크드리스트가<br>
유리하며, 데이터의 크기가 정해져있고, 삽입 삭제가 적으며 검색을 필요로한다면 배열리스트가 유리하다.<br>

ps : 배열은 메모리가 연속적이어서 주소값을 일정한 크기로 더해주며 검색하기 때문에 속도가 비교적 빠르다. O(1)<br>
반면 링크드리스트는 불연속적이어서 다음 공간을 찾아가는데까지 시간이 더 소요된다. 최악일 경우 O(n)<br>
<br>

### List 예 <br>
문자형 데이터가 저장될때<br>
문자열이 차례로 저장될때<br>
행렬<br>
다항식<br>
<br>

## 리스트 추상 자료형 <br>
리스트 생성 createList() -> 배열리스트인 경우에만 최대 원소 개수인 n을 지정해줘야함.<br>
리스트 삭제 deleteList()<br>
원소 추가 가능 여부판단 isFull() -> 이것도 배열리스트인 경우에만 의미가 있을 것임.<br>
원소 추가 addElement()<br>
원소 제거 removeElement()<br>
리스트 초기화 clearList()<br>
원소 개수 getListLength()<br>
원소 반환 getElement()<br>
<br>

## 단순 연결리스트 구현 (소스참고)<br>
헤더 노드를 이용하는 이유는 헤드 포인터를 사용할때보다 구현이 간편하기 때문임.

리스트의 생성<br>
노드 추가/제거<br>
원소반환과 리스트 순회<br>
등등<br>
<br>

## 원형 연결리스트 구현 및 특징 (소스참고)<br>
단순연결리스트와 다르게 tail 포인터를 고려해야 하기 때문에, 노드 삽입 삭제 시 특별케이스들이 존재한다.<br>

<br>

![원형연결](https://user-images.githubusercontent.com/43705434/109810082-6c497e00-7c6c-11eb-9436-99dcb8b65ffc.png)<br>

<br>

**데이터 추가 시**<br>
1. 빈 리스트에 노드를 추가할 때 - header, tail을 모두 해당 노드로 지정 후 셀프순환<br>
2. 노드가 존재하는 리스트의 맨 앞에 노드를 새로 추가할 때 - header를 해당 노드로 지정하고 tail이 가리키게 해야한다.<br>
3. 노드가 존재하는 리스트의 맨 뒤에 노드를 새로 추가할 때 - tail 포인터를 새로 추가된 노드로 옮겨주어야 한다.<br>
4. 노드가 존재하는 리스트의 임의의 위치에 노드를 추가할 때 - 일반적인 경우<br>
<br>

**데이터 삭제 시**<br>
1. 첫번째 노드를 삭제하는데 삭제 후 빈리스트가 되는 경우 - header, tail을 모두 null 처리<br>
2. 첫번째 노드를 삭제하는 경우 - header를 다음 노드로 변경해야하며, tail이 해당 노드를 가리키게 해야한다.<br>
3. 일반적인 중간노드를 삭제하는 경우 - 일반적인 경우<br>

> 원형 연결리스트의 경우 header, tail 포인터를 각각 하나만 사용하는 경우와, 둘 모두 사용하는 경우로 나눌 수 있다<br>
> 어떤 방법으로 구현하던지 상관은 없다.<br>

**원형 연결리스트의 특징**<br>
* 하나의 노드에서 링크를 계속 따라가면 결국 모든 노드를 거쳐서 자기 자신으로 되돌아 올 수 있다.<br>
* header와 tail 포인터를 운용하기 때문에 맨앞에 항목슬 삽입, 삭제 하는 것이 O(1)만에 가능하며 맨뒤는 삽입만 O(1)만에 가능하다.<br>
-> 반복해서 순회 할 수 있다는 장점도 있지만, 2번째 항목처럼 맨앞이나 맨뒤에 항목을 삽입, 삭제하는데 드는 비용이 더 적은 장점도 있다.<br>  
<br>

## 이중 연결리스트 구현 및 특징(소스참고)<br>
단순 이중 연결리스트와 원형 이중 연결리스트 2가지를 구현해서 소스를 올려놨는데, 원형 이중 연결리스트가 좀 더 유동성있고<br>
여러 방면으로 활용도가 높아보였다. 구현팁은 원형 연결리스트와 마찬가지로 데이터의 삽입, 삭제 시 맨앞과 맨뒤, 중앙을 나누어서<br>
생각해보면 쉬워진다.<br>
<br>
![이중연결사진](https://user-images.githubusercontent.com/43705434/109810081-6bb0e780-7c6c-11eb-8dff-5fbab1419c99.png)<br>
![원형이중연결리스트결과](https://user-images.githubusercontent.com/43705434/109810078-6a7fba80-7c6c-11eb-934d-8e4a7a3eb365.PNG)<br>
<br>

**장점**<br>
* 이전 노드에 바로 접근이 가능하기 때문에, 데이터의 삽입, 삭제 연산에 있어서 훨씬 효율적인 운용이 가능하다.<br>
* 단순 원형 연결리스트는 맨뒤 항목의 삭제에 있어서 O(1)만에 해결할 수 없었는데, 이중 연결리스트는 prev로 이동이 가능해 O(1)에 가능하다.<br>
<br>

**단점**<br>
* 이전 노드를 가리킬 포인터가 따로 필요하므로 메모리가 더 소모되며, 구현이 복잡하다.<br>
