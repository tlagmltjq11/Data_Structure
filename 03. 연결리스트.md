## 리스트의 개념 <br>
리스트란 자료를 순서대로 저장하는 자료구조를 의미한다. -> 구조가 단순함.<br>
이때 여러 자료들은 서로 선형으로 연결되어있는 구조다. <앞뒤 관계가 1:1><br>
![링크드리스트](https://user-images.githubusercontent.com/43705434/108394195-cd7a5600-7257-11eb-9f94-16ebe2241ae5.png)

<br>

## Array vs Array List (배열을 이용해 구현한 리스트)<br> 
애초에 배열 vs 배열로 구현한 리스트 이기 때문에 비교선상에 놓기에는 어색한 감이 있지만 굳이 비교 해보겠다.<br> 
* 중간에있는 데이터가 삭제되었을때, 배열리스트는 선형적으로 모든 데이터가 연결되어있어야 하기 때문에,<br> 
해당 빈공간만큼 앞으로 앞당겨줘 연결시켜줘야한다. 또한 추가할때에는 뒤로 밀어줘야한다.<br>

> 배열은 중간에 데이터를 삽입, 삭제 한다는 개념이 아니라 그저 overwrite 일 뿐이다.<br>
<br>

* 배열리스트는 동적으로 메모리를 늘리고 줄일 수 있다. 하지만 배열은 정적으로 런타임중 메모리를 변경할 수 없다.<br>
<br>

* 배열리스트는 데이터 추가, 삭제 시 기존 데이터들을 밀고 당겨줘야 하며, 메모리 부족 시 realloc을 하기도 하기 때문에<br>
배열보다 연산 속도가 느리다.<br>
<br>
<br>

## Array vs LinkedList <br>
배열 : 연속적으로 메모리 공간을 차지, 정적<br>
링크드리스트 : 불연속적으로 메모리 공간을 차지, 동적<br>
<br>

## 배열리스트 <br>
**장점 : 배열을 이용해 만든 리스트이기 때문에, 인덱스를 통해 빠른 검색 연산이 가능하며, 구현이 간단하다.**<br>

**단점 : 배열의 크기를 가변적으로 사용할 수 있지만, 기존의 데이터를 전부 복사해야하기에 연산적으로 비효율적이다.**<br>
또한, 데이터 추가, 삭제 시 원소의 이동이 빈번하기 때문에 연산이 많이 들며, 느리다.<br>
<br>

**구현 Tip.**<br>
1. 배열리스트의 메모리를 동적으로 늘리기 위해서는 realloc을 사용하면 된다.<br>
<br>

## 링크드리스트 <br>
**장점 : 링크드리스트는 포인터를 이용하기때문에 크기가 제한되지 않으며, 불연속적으로 메모리 공간을 차지 할 수 있어<br> 
메모리의 관리 및 재사용이 편리하다. 또한 원소를 중간에 삽입, 삭제 하는 것이 용이하다**<br>

**단점 : 포인터를 이용하기 때문에, 다음 데이터를 가르킬 추가적인 메모리 공간이 발생된다<br>
또한 헤더 포인터부터 순차적으로 순회해야 하기 때문에 검색 성능이 좋지 않다.**<br>
<br>

**구현 Tip.**<br>
1. 노드 구조체는 데이터와 다음 노드를 가리킬 노드 포인터를 가져야 한다. (자기 참조 구조체)<br>
2. 링크드리스트 구조체는 리스트의 시작을 알릴 헤더 포인터를 가져야 한다.<br>
<br>

### 배열리스트 vs 링크드리스트<br>
데이터의 크기가 정해져있지 않고, 삽입 삭제가 많이 일어나며 검색이 적은 경우에는 링크드리스트가<br>
유리하며, 데이터의 크기가 정해져있고, 삽입 삭제가 적으며 검색을 필요로한다면 배열리스트가 유리하다.<br>

ps : 배열은 메모리가 연속적이어서 주소값을 일정한 크기로 더해주며 검색하기 때문에 속도가 비교적 빠르다. O(1)<br>
반면 링크드리스트는 불연속적이어서 다음 공간을 찾아가는데까지 시간이 더 소요된다. 최악일 경우 O(n)<br>
<br>

### 리스트의 예 <br>
문자형 데이터가 저장될때<br>
문자열이 차례로 저장될때<br>
행렬<br>
다항식<br>
<br>

## 리스트 추상 자료형 <br>
리스트 생성 createList() -> 배열리스트인 경우에만 최대 원소 개수인 n을 지정해줘야함.<br>
리스트 삭제 deleteList()<br>
원소 추가 가능 여부판단 isFull() -> 이것도 배열리스트인 경우에만 의미가 있을 것임.<br>
원소 추가 addElement()<br>
원소 제거 removeElement()<br>
리스트 초기화 clearList()<br>
원소 개수 getListLength()<br>
원소 반환 getElement()<br>
<br>

## 링크드 리스트의 개념<br> 

배열리스트는 배열을 이용했기 때문에, 메모리가 순차적으로 잡혀있지만<br>
링크드리스트는 포인터를 이용한 리스트여서, 메모리가 논리적으로 즉 물리적으로 순차적이지 않게 잡힐 수 있다.<br>
-> 고로 링크드리스트는 최대원소개수 지정이 필요없다!★<br>

> Node = 데이터 + 링크

연결리스트에서 데이터를 추가하는것은 링크의 정보를 추가하는것.
<br>
<br>

## 링크드리스트 vs 배열리스트 <br>

링크드 리스트의 장점 : 배열리스트는 원소 추가/삭제시 다른 원소들을 이동시켜줘야하지만, 링크드리스트는<br>
이동연산 필요없이 포인터만 연결/해제 해주면 되기때문에 비용이 훨씬 가볍다.<br>
또한 최대원소개수를 지정해주지 않아도 된다.<br>

단점 : 구현하기가 좀 더 복잡.<br>
또한 탐색연산이 좀 더 오래걸린다. -> 메모리가 비순차적으로 잡혀있기 때문임.<br>
<br>

## 연결리스트의 종류 <br>
단순 연결 리스트 -> -> -> -><br>
원형 연결 리스트 -> -> -> -> 첫번째<br>
이중 연결 리스트 -> -> -> -><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<- <- <- <-<br>

![리스트](https://user-images.githubusercontent.com/43705434/108394199-ce12ec80-7257-11eb-8e0f-a4376148c619.png)

- Previous 노드에 대한 접근?<br>
단순연결리스트는 이전 노드에 접근이 불가능<br>
원형연결리스트는 계속 돌다보면 다시 처음부터 돌기때문에 접근가능<br>
이중연결리스트는 양방향이기에 바로 접근가능<br>
<br>

## 단순연결리스트 구현 (소스참고)<br>
헤더노드를 이용하는 이유는 헤드 포인터를 사용할때보다 구현이 간편하기 때문임.

리스트의 생성<br>
노드 추가/제거<br>
원소반환과 리스트 순회<br>
등등<br>
<br>

## 원형연결리스트 구현 (소스참고)<br>
단순연결리스트와 다르게 노드 추가시에 특별케이스들이 존재한다.<br>

1. 빈 리스트에 노드를 추가할 때<br>
2. 노드가 존재하는 리스트에 맨앞에 노드를 새로 추가할 때<br>
3. 노드가 존재하는 리스트에 임의의 위치에 노드를 추가할 때<br>

1,2는 맨마지막노드가 맨처음노드를 가르키게하는 과정에서 차이가나게됨.★
<br>

노드를 삭제할때에도 마찬가지로 다음 케이스들을 염두에두고 설계해야한다.★<br>
1. 첫번째 노드를 삭제하는데 삭제 후 빈리스트가 되는 경우<br>
2. 첫번째 노드를 삭제하는 경우<br>
3. 일반적인 중간노드를 삭제하는 경우<br>

> 원형 연결리스트의 경우 header, tail 포인터를 각각 하나만 사용하는 경우와, 둘 모두 사용하는 경우로 나눌 수 있다<br>
> 어떤 방법으로 구현하던지 상관은 없다.<br>

그 외에는 링크드리스트와 크게 다를것 없이 구현이 진행됨!<br>
<br>

## 이중연결리스트 구현 (소스참고)<br>

장점은 이전노드에 바로 접근이가능함.<br>
40 -> 30 -> 20 -> 10이라고할때 20왼쪽노드를 삭제하고싶다면, 기존 연결리스트에서는<br>
30을 가르키는 before노드가 하나 더 필요하게된다. 이러한 단점을 보완한것이 이중연결리스트임.<br>
20왼쪽노드를 삭제하고싶다면, 곧바로 20의 prev를 이용하여 삭제할 수 있음.★★★<br>
<br>
단점은 추가적인 메모리가 필요하다는것.
