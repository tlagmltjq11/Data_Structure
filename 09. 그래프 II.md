## 신장트리
신장트리란 그래프내의 모든 정점을 포함하는 트리를 의미한다.<br>
모든 정점들이 연결되어 있어야 하고 사이클을 포함해서는 안된다.<br>
> 따라서 신장트리는 그래프에 있는 n개의 정점을 정확히 n-1개의 간선으로 연결하게 된다.<br>
> 고로 신장트리는 그래프의 최소 연결 부분 그래프가 된다!<br>
<br>

신장트리는 DFS, BFS 도중 사용된 간선을 모으면 만들 수 있다.<br>
<br>

✔️ **어디에 사용될까?**<br>
네트워크 구축에 많이 사용된다. 예를 들어 N개의 위치를 연결하는 통신 네트워크를 최소의 링크를 이용하여 구축하고자 할 경우,<br>
최소 링크수는 N-1이 되고 따라서 신장 트리들이 가능한 대안이 된다.<br>
<br>

그러나 각 링크의 구축 비용은 똑같지 않다. -> **최소 비용 신장트리** 를 사용해야 한다!<br>
<br>

## 최소 비용 신장트리 (MST)
최소 비용 신장트리는 신장트리 중에서 사용된 간선들의 가중치 합이 최소인 신장 트리를 말한다.<br>
<br>

✔️ **응용 예**<br>
1. 도로건설 - 도시들을 모두 연결하면서 도로의 길이가 최소가 되도록 하는 문제
2. 전기회로 - 단자들을 모두 연결하면서 전선의 길이가 가장 최소가 되도록 하는 문제
3. 통신 ..
4. 배관 ..
<br>

이러한 최소 비용 신장트리를 구하는 방법으로는 **Kruskal** 과 **Prim** 이 제안한 알고리즘이 대표적으로 사용된다.<br>
<br>

## Kruskal 알고리즘
크루스칼 알고리즘은 **탐욕적인 (Greedy) 방법** 을 사용한다.<br>
<Greedy 알고리즘은 항상 최적의 해를 보장하지 않는데 크루스칼은 최적의 해답을 주는것으로 증명되어 있다.><br>
<br>

최소 비용 신장트리가 최소 비용의 간선으로 구성됨과 동시에 사이클을 포함하지 않는다는 조건에 근거하여,<br>
매 단계마다 사이클을 이루지 않는 최소 비용 간선을 선택한다.<br>
<br>

✔️ **알고리즘 단계** <br>
1. 우선 간선들을 가중치의 오름차순으로 정렬한다.
2. 정렬된 간선들의 리스트에서 사이클을 형성하지 않는 간선을 찾아서 현재의 최소 비용 신장트리 집합에 추가한다.
<사이클을 형성하는 간선은 제외된다.><br>
3. n-1개의 간선을 선택하게되면 종료한다.
<br>

✔️ **사이클을 생성하는지 체크** <br>
아무래도 나머지 부분들은 정렬 후 선택.. 처럼 너무나도 간단하기에 사이클 생성 여부 체크가 크루스칼 알고리즘에서 가장 중요한 부분일 것이다.<br>
> 간선의 양끝 정점이 같은 집합에 속하면 간선을 추가하였을 경우, 사이클이 형성된다.<br>
> 즉 이미 다른 경로에 의해 연결되어있는 정점들을 연걸하고자 할때 사이클이 형성되는 것이다.<br>
<br>

고로 간선의 양끝 정점이 같은 집합에 속해있는지 검사하여야 하는데, 이러한 알고리즘을 **Union-Find** 알고리즘이라 한다.<br>
<br>

크루스칼은 간선을 정렬해서 선택하는 **간선기반 알고리즘** 이기 때문에 그래프가 간선들의 집합으로 이루어지도록 구현한다.<br>
```C
struct Edge
{
  int start, end, weight;
};

typedef struct Graph
{
  int n; //간선 개수
  int v; //정점 개수
  struct Edge edges[2 * MAX_VERTICES]; //간선들
}Graph;
```
<br>

✔️ **구현 (Union-Find 참고)** <br>
```C
void Kruskal(Graph* g)
{
	int edge_accepted = 0; //현재 선택된 간선의 수
	int uset, vset; //정점 u와 v의 집합 번호
	struct Edge e;

	qsort(g->edges, g->n, sizeof(struct Edge), compare); //간선 정렬
	
	printf("크루스칼 최소 신장 트리 알고리즘 \n");
	int i = 0;

	while(edge_accepted < (g->v - 1)) // 선택된 간선의 수가 n-1이 되면 종료
	{
		e = g->edges[i]; //순서대로 간선을 받아온다.
		uset = Set_Find(e.start); //간선의 시작 정점이 포함된 집합 반환
		vset = Set_Find(e.end); //간선의 끝 정점이 포함된 집합 반환

		if (uset != vset) //서로 속한 집합이 다르다면
		{
			printf("간선 (%d, %d) %d 선택 \n", e.start, e.end, e.weight);
			edge_accepted++; //간선 선택 + 1
			Set_Union(uset, vset); //두 집합이 연결되었으므로 합쳐준다.
		}

		i++;
	}
}
```
<br>

✔️ **시간 복잡도 분석** <br>
Union-Find 알고리즘을 이용하면 크루스칼의 알고리즘 시간복잡도는 간선들을 정렬하는 시간에 좌우된다.<br>
따라서 효율적인 정렬 알고리즘을 사용한다면 간선이 e개인 경우 시간 복잡도는 **O(eloge)** 이다.<br>
<br>
<br>

## Union-Find 알고리즘
크루스칼에만 한정적인 알고리즘이 아니라 일반적으로 널리 사용되는 알고리즘인것을 주의하자.<br>
Union-Find 알고리즘은 Union 즉 합집합 연산과 Find 즉 검색 후 반환 연산을 의미한다.<br>
Union(x, y) : 원소 x와 y가 속해있는 집합을 입력으로 받아 2개의 집합을 합집합 한다.<br>
Find(x) : 원소 x가 속해있는 집합을 반환한다.<br>
<br>

✔️ **구현**<br>
배열, 연결 리스트, 비트벡터 등 여러가지 방식으로 구현할 수 있지만 가장 효율적인 방식은 **트리** 형태를 사용하는 것이다.<br>
1차원 배열을 이용해서 구현하는데 각 원소들은 자신의 부모노드의 인덱스를 값으로 갖는다.<부모 노드가 없다면 -1> <br>
이는 일반적인 트리에는 부적합하지만 두 노드가 같은 트리에 있습니까? 라는 질문에 필요한 정보는 저장하고 있다.<br>
<br>

루트 노드는 -1 값을 가지며, parent[] 배열을 이용해 트리를 형성한다.<br>
<br>

```C
Find(cur):

  if(parent[cur] == -1) //부모 노드가 없다면
    return cur; //혼자 집합을 이루므로 cur을 그대로 다시 반환
    
  while(parent[cur] != -1) cur = parent[cur]; //루트 부모노드를 찾는다.
  return cur;
```
<br>

```C
Union(x, y):
  
  root1 = Find(x); //집합의 루트를 찾는다.
  root2 = Find(y); //집합의 루트를 찾는다.
  
  if( root1 != root2) //만약 서로 다른 집합이라면
    parent[root1] = root2; //한 집합의 부모를 다른 집합으로 엮어 두 집합을 합친다.
```
<br>
<br>

## Prim 알고리즘
프림 알고리즘은 시작 정점에서부터 출발하여 신장 트리 집합을 단계적으로 확장해나가는 방법이다. 이 역시 **그리디** 한 방식의 알고리즘이다.<br>
앞 단계에서 만들어진 신장 트리 집합에 인접한 정점들 중에서 최저 간선으로 연결된 정점을 선택하여 트리를 확장한다.<br>
<br>

프림 알고리즘은 크루스칼과 반대로 **정점을 기반** 으로 하는 알고리즘이다.<br>

✔️ **알고리즘 단계**<br>
1. 임의의 정점을 선택하여 비어있는 T에 포함시킨다. (이제 T는 노드가 한 개인 트리.)
2. T 에 있는 노드와 T 에 없는 노드 사이의 간선 중 가중치가 최소인 간선을 찾는다.
3. 찾은 간선이 연결하는 두 노드 중, T 에 없던 노드를 T에 포함시킨다. 
4. 모든 노드가 T 에 포함될 때 까지, 1,2 를 반복한다.
<br>

✔️ **구현**<br>
프림 알고리즘은 대게 효율성을 위해 **우선순위 큐** 를 이용해서 구현하지만, 배열로도 구현이 가능하다.<br>
코드는 다음 링크에서 참고<br>
https://www.weeklyps.com/entry/%ED%94%84%EB%A6%BC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-Prims-algorithm<br>
<br>

✔️ **시간 복잡도 분석**<br>
우선순위 큐를 이용한다면 **O(elogv)** 이며, 배열을 이용한다면 **O(v^2)** 이다.<br>
<br>

**따라서 프림 알고리즘은 간선의 개수에 비해 정점의 개수가 적은 경우 유리한 알고리즘이며,<br>
또한 크루스칼은 정점의 개수에 비해 간선의 개수가 적은 경우 유리한 알고리즘이다.<br>
고로 문제에 알맞게 채택해서 사용하면 된다.**<br>
<br>
<br>

## 최단 경로
최단 경로 문제는 가중치 그래프에서 정점 i와 정점 j를 연결하는 경로 중 간선들의 가중치 합이 최소가 되는 경로를 찾는 문제이다.<br>
<br>

이렇게 그래프내에서 최단 경로를 찾는 알고리즘에는 대표적으로 Dijkstra, Floyd가 존재한다.<br>
<br>

## Dijkstra 알고리즘
다익스트라가 제시한 최단 경로 알고리즘은 가중치 그래프에서 **하나의 시작 정점으로부터 다른 모든 정점까지의 최단 경로** 를 찾는 알고리즘이다.
역시 탐욕적인 방식으로 알고리즘이 진행되며, 최단경로들은 경로의 길이 순으로 구해진다.<br>
<br>

네비게이션, 지하철 노선도..<br>
<br>

✔️ **알고리즘 단계**<br>
1. 시작점의 거리를 0으로 저장한다.
2. 아직 방문하지 않은 정점 중에서 거리가 가장 짧은 정점을 선택한다.
3. 선택된 정점 v는 최단거리가 확정
4. 선택한 정점을 통해 다른 정점까지의 거리가 짧아지는지 계산한다.
5. 모든 정점이 선택될 때까지 2~4를 반복한다.
<br>

✔️ **구현**<br>
distance[] 배열은 최단경로가 발견된 정점들의 집합인 S에 있는 정점만을 거쳐서 다른 정점으로 가는 거리와 시작 정점에서 곧바로 도착 정점으로 가는 거리의
최소값을 저장한다. 이때 **간선이 존재하지않으면 인접행렬에 무한대값** 이 저장되어있기 때문에 값을 비교하게되면 S내 정점들을 경유하는 거리가 저장될 것이다. <br>
<br>

```C
Dijkstra(G, v): 그래프, 시작정점
	
	S집합에 v를 포함; //Found[v] = TRUE; 로 표현
	for 각 정점 w in 그래프 do
		distance[w] = weight[v][w]; //인접행렬 값으로 초기화
		
	while(모든 정점이 S에 포함되지 않으면) do
		u = 집합 S에 속하지 않는 정점 중에서 최소 distance[]값을 갖는 정점;
		S집합에 u를 포함;
		
		for(w = 0; w < g->n; w++)
		{
			if(!Found[w])
			{
				if(distance[u] + g->weight[u][w] < distance[w]) //u를 거쳐서 다른 정점으로 가는길이 더 최단인지 비교하는 것.
					distance[w] = distance[u] + g->weight[u][w];
			}
		}		
```
<br>

정점을 방문할때마다 인접한 정점을 모두 검사하기 때문에 **BFS** 와 유사하다.<br>
최소 distance[]값을 갖는 정점을 고르는 함수를 우선순위 큐로 대치하면 더 빠르게 수행할 수 있다.<br>
<br>

✔️ **시간 복잡도 분석**<br>
우선순위 큐를 이용하면 **O(elogv)** , 배열만을 이용한다면 **O(v^2)** 만큼 소요된다.<br>
<br>
<br>

## Floyd 알고리즘
그래프에 존재하는 모든 정점 사이의 최단 경로를 구하려면 다익스트라의 알고리즘을 정점의 수 만큼 반복 실행해야 한다.<br>
그러나 더 간단하고 좋은 알고리즘으로 Floyd 알고리즘이 존재한다. 해당 알고리즘은 그래프에 존재하는 모든 정점 사이의 <br>
최단 경로를 한 번에 모두 찾아주는 알고리즘이다.<br>
<br>

✔️ **구현**<br>
구현 알고리즘은 굉장히 단순하다 3중 반복문을 돌면서 도착점에 대해 특정 정점을 거쳐서 가는 경우와 그냥 가는 경우를 비교하며 갱신하여<br>
배열내 값들을 계속해서 누적해주면 된다.<br>
<br>

```C
void Floyd(Graph * g)
{
	for(int i=0; i<g->n; i++)
	{
		for(int j=0; j<g->n; j++)
		{
			A[i][j] = g->weight[i][j]; //인접행렬의 가중치값으로 A배열 초기화
		}
	}
	
	for(int k=0; k<g->n; k++)
	{
		for(int i=0; i<g->n; i++)
		{
			for(int j=0; j<g->n; j++)
			{
				if(A[i][k] + A[k][j] < A[i][j]) //k를 거쳐서 가는 경로가 더 최단이라면 갱신해준다.
				{
					A[i][j] = A[i][k] + A[k][j];
				}
			}	
		}
	}
}
```
<br>

✔️ **시간 복잡도 분석**<br>
다익스트라를 사용해서 모든 정점간의 최단경로를 구하려면 원래 O(n^2)이 걸리던 알고리즘을 정점의 수 만큼 즉 n번 수행해야 하므로<br>
O(n^3)이 걸린다. 플로이드 알고리즘 역시 위 구현 코드를 보면 **O(n^3)** 인 것을 알 수 있다. 하지만 플로이드 알고리즘은<br>
**매우 간결한 반복 구문을 사용하므로 다익스트라에 비해 굉장히 단순해 성능이 훨씬 빠르다.** <br>
하지만 특정 모든 정점간의 최단경로를 구하지 않아도 되는 경우라면 다익스트라를 사용하는것이 더 효율적인건 당연하다.<br>
<br>

## 위상 정렬
방향 그래프에서 간선 <u, v>가 있따면 정점 u는 정점 v를 선행한다고 말한다.<br>
이때 각 정점들의 선행 순서를 위배하지 않으면서 모든 정점을 나열하는 것을 위상 정렬(Topological sort)라고 한다.<br>
한 그래프내에서도 여럿의 위상 순서가 존재할 수 있다<br>
<br>

✔️ **알고리즘 단계**<br>
1. 먼저 진입 차수가 0인 정점을 선택하고 해당 정점과 여기에 부착된 모든 간선을 삭제한다.
2. 1번을 반복하며 모든 정점이 선택-삭제 되면 알고리즘을 종료한다.
<br>

이때 진입 차수가 0인 정점이 여럿 존재한다면 어떤것을 먼저 선택해도 상관이 없으며, 만약 진입 차수가 0인 정점이<br>
그래프내에 없다면 해당 그래프는 위상 순서가 존재하지 않는 것으로 판별된다.<br>
<br>

✔️ **구현**<br>
구현 시 진입차수가 0인 후보 정점들을 스택에 넣어 관리한다.<br>

```C
int Topo_sort(Graph* g)
{
	int i;
	Stack s;
	GraphNode* node;

	//모든 정점의 진입 차수 계산
	int* in_degree = (int*)malloc(sizeof(int) * g->n);
	for (i = 0; i < g->n; i++)
	{
		in_degree[i] = 0;
	}
	for (i = 0; i < g->n; i++)
	{
		node = g->adj_List[i];
		while (node != NULL)
		{
			in_degree[node->vertex]++; //진입차수 계산
			node = node->link;
		}
	}

	Init_Stack(&s);
	//진입 차수가 0인 정점을 스택에 삽입
	for (i = 0; i < g->n; i++)
	{
		if (in_degree[i] == 0)
		{
			Push(&s, i);
		}
	}

	//위상 정렬 생성
	while (!isEmpty(&s))
	{
		int w;
		w = Pop(&s);
		printf("정점 %d ->", w);
		node = g->adj_List[w];
		while (node != NULL)
		{
			int u = node->vertex;
			in_degree[u]--;
			if (in_degree[u] == 0)
			{
				Push(&s, u);
			}

			node = node->link;
		}
	}

	free(in_degree);
	printf("\n");
	return (i == g->n);
}
```
<br>

