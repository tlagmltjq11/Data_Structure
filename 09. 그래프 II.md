## 신장트리
신장트리란 그래프내의 모든 정점을 포함하는 트리를 의미한다.<br>
모든 정점들이 연결되어 있어야 하고 사이클을 포함해서는 안된다.<br>
> 따라서 신장트리는 그래프에 있는 n개의 정점을 정확히 n-1개의 간선으로 연결하게 된다.<br>
> 고로 신장트리는 그래프의 최소 연결 부분 그래프가 된다!<br>
<br>

신장트리는 DFS, BFS 도중 사용된 간선을 모으면 만들 수 있다.<br>
<br>

**어디에 사용될까?**<br>
네트워크 구축에 많이 사용된다. 예를 들어 N개의 위치를 연결하는 통신 네트워크를 최소의 링크를 이용하여 구축하고자 할 경우,<br>
최소 링크수는 N-1이 되고 따라서 신장 트리들이 가능한 대안이 된다.<br>
<br>

그러나 각 링크의 구축 비용은 똑같지 않다. -> **최소 비용 신장트리** 를 사용해야 한다!<br>
<br>

## 최소 비용 신장트리 (MST)
최소 비용 신장트리는 신장트리 중에서 사용된 간선들의 가중치 합이 최소인 신장 트리를 말한다.<br>
<br>

**응용 예**<br>
1. 도로건설 - 도시들을 모두 연결하면서 도로의 길이가 최소가 되도록 하는 문제
2. 전기회로 - 단자들을 모두 연결하면서 전선의 길이가 가장 최소가 되도록 하는 문제
3. 통신 ..
4. 배관 ..
<br>

이러한 최소 비용 신장트리를 구하는 방법으로는 **Kruskal** 과 **Prim** 이 제안한 알고리즘이 대표적으로 사용된다.<br>
<br>

## Kruskal 알고리즘
크루스칼 알고리즘은 **탐욕적인 (Greedy) 방법** 을 사용한다.<br>
<Greedy 알고리즘은 항상 최적의 해를 보장하지 않는데 크루스칼은 최적의 해답을 주는것으로 증명되어 있다.><br>
<br>

최소 비용 신장트리가 최소 비용의 간선으로 구성됨과 동시에 사이클을 포함하지 않는다는 조건에 근거하여,<br>
매 단계마다 사이클을 이루지 않는 최소 비용 간선을 선택한다.<br>
<br>

**알고리즘 단계** <br>
1. 우선 간선들을 가중치의 오름차순으로 정렬한다.
2. 정렬된 간선들의 리스트에서 사이클을 형성하지 않는 간선을 찾아서 현재의 최소 비용 신장트리 집합에 추가한다.
<사이클을 형성하는 간선은 제외된다.><br>
3. n-1개의 간선을 선택하게되면 종료한다.
<br>

**사이클을 생성하는지 체크** <br>
아무래도 나머지 부분들은 정렬 후 선택.. 처럼 너무나도 간단하기에 사이클 생성 여부 체크가 크루스칼 알고리즘에서 가장 중요한 부분일 것이다.<br>
> 간선의 양끝 정점이 같은 집합에 속하면 간선을 추가하였을 경우, 사이클이 형성된다.<br>
> 즉 이미 다른 경로에 의해 연결되어있는 정점들을 연걸하고자 할때 사이클이 형성되는 것이다.<br>
<br>

고로 간선의 양끝 정점이 같은 집합에 속해있는지 검사하여야 하는데, 이러한 알고리즘을 **Union-Find** 알고리즘이라 한다.<br>
<br>

## Union-Find 알고리즘
크루스칼에만 한정적인 알고리즘이 아니라 일반적으로 널리 사용되는 알고리즘인것을 주의하자.<br>
Union-Find 알고리즘은 Union 즉 합집합 연산과 Find 즉 검색 후 반환 연산을 의미한다.<br>
Union(x, y) : 원소 x와 y가 속해있는 집합을 입력으로 받아 2개의 집합을 합집합 한다.<br>
Find(x) : 원소 x가 속해있는 집합을 반환한다.<br>
<br>

**구현**<br>
배열, 연결 리스트, 비트벡터 등 여러가지 방식으로 구현할 수 있지만 가장 효율적인 방식은 **트리** 형태를 사용하는 것이다.<br>
1차원 배열을 이용해서 구현하는데 각 원소들은 자신의 부모노드의 인덱스를 값으로 갖는다.<부모 노드가 없다면 -1> <br>
이는 일반적인 트리에는 부적합하지만 두 노드가 같은 트리에 있습니까? 라는 질문에 필요한 정보는 저장하고 있다.<br>
<br>

루트 노드는 -1 값을 가지며, parent[] 배열을 이용해 트리를 형성한다.<br>
<br>

```C
Find(cur):

  if(parent[cur] == -1) //부모 노드가 없다면
    return cur; //혼자 집합을 이루므로 cur을 그대로 다시 반환
    
  while(parent[cur] != -1) cur = parent[cur]; //루트 부모노드를 찾는다.
  return cur;
```
<br>

```C
Union(x, y):
  
  root1 = Find(x); //집합의 루트를 찾는다.
  root2 = Find(y); //집합의 루트를 찾는다.
  
  if( root1 != root2) //만약 서로 다른 집합이라면
    parent[root1] = root2; //한 집합의 부모를 다른 집합으로 엮어 두 집합을 합친다.
```
<br>

