## 그래프
그래프는 객체 사이의 연결 관계를 표현할 수 있는 자료 구조로 단순히 노드(n, Node)와 그 노드를 연결하는<br>
간선(e, Edge)을 하나로 모아 놓은 것이다.<br>
<br>

Ex) 지하철 노선도, 전기회로 소자, 운영체제에서 프로세스와 자원들을 그래프로 분석.. <br>
위와같은 많은 문제들은 공통적으로 객체들이 서로 연결되어 있는 구조로 표현이 가능하기에 그래프를 이용한다.<br>
<br>

**그래프와 트리의 차이**<br>
<br>

**오일러 경로**<br>
모든 간선을 한번만 통과하면서 처음 정점으로 돌아오는 경로를 오일러 경로라고 한다.<br>
> 그래프의 모든 정점에 연결된 간선의 개수가 짝수일 때만 오일러 경로가 존재한다는 오일러의 정리를 증명함<br>

따라서 그래프는 오일러의 정리에 의해 오일러 경로가 존재하지 않는다는 것을 복잡한 시행착오 없이 손쉽게 알 수 있다.<br>
<br>

## 그래프의 정의와 용어
**그래프의 정의**<br>
그래프는 정점과 간선의 유한집합으로 **정점**은 여러가지 특성을 가질 수 있는 **객체**를 의미하고, **간선**은 이러한 정점들 간의 **관계**를 의미한다.<br>
<br>

**기본용어**<br>
* 정점(vertex): 위치라는 개념. (node 라고도 부름)<br>
* 간선(edge): 위치 간의 관계. 즉, 노드를 연결하는 선 (link, branch 라고도 부름)<br>
* 인접 정점(adjacent vertex): 간선에 의해 직접 연결된 정점<br>
* 정점의 차수(degree): 무방향 그래프에서 하나의 정점에 인접한 정점의 수<br>
* 무방향 그래프에 존재하는 정점의 모든 차수의 합 = 그래프의 간선 수의 2배 <하나의 간선이 두 정점에 연결되기 때문><br>
* 진입 차수(in-degree): 방향 그래프에서 외부에서 오는 간선의 수 (내차수 라고도 부름)<br>
* 진출 차수(out-degree): 방향 그래픙에서 외부로 향하는 간선의 수 (외차수 라고도 부름)<br>
* 방향 그래프에 있는 정점의 진입 차수 또는 진출 차수의 합 = 방향 그래프의 간선의 수(내차수 + 외차수)<br>
* 경로 길이(path length): 경로를 구성하는 데 사용된 간선의 수<br>
* 단순 경로(simple path): 경로 중에서 반복되는 정점이 없는 경우<br>
* 사이클(cycle): 단순 경로의 시작 정점과 종료 정점이 동일한 경우<br>
<br>

## 그래프의 종류
**무방향 그래프와 방향 그래프**<br>
간선의 종류에 따라 그래프는 무방향, 방향으로 구분된다.<br>
<br>

무방향 그래프<br> 
무방향 그래프의 간선은 간선을 통해서 양방향으로 갈 수 있음을 나타내며 간선은 (A, B)와 같이 표현한다.<br>
<br>

방향 그래프<br>
방향 그래프는 간선에 방향성이 존재하는 그래프로서 간선을 통해 한쪽 방향으로만 갈 수 있음을 나타내며 간선을 <A, B>와 같이 표현한다.<br>
<br>

**가중치 그래프(Network)**<br>
간선에 비용이나 가중치가 할당된 그래프로 간선으로 연결 강도까지 나타낼 수 있어 보다 복잡한 관계를 표현할 수 있다.<br>
‘네트워크(Network)’ 라고도 한다.<br>
Ex) 도시-도시의 연결, 도로의 길이, 회로 소자의 용량, 통신망의 사용료 등<br>
<br>

**연결 그래프 VS 비연결 그래프**<br>
연결 그래프(Connected Graph)<br>
무방향 그래프에 있는 모든 정점쌍에 대해서 항상 경로가 존재하는 경우<br>
Ex) 트리(Tree): 사이클을 가지지 않는 연결 그래프<br>
<br>

비연결 그래프(Disconnected Graph)<br>
무방향 그래프에서 특정 정점쌍 사이에 경로가 존재하지 않는 경우<br>
<br>

**완전 그래프**<br>
그래프에 속해 있는 모든 정점이 서로 연결되어 있는 그래프<br>
무방향 완전 그래프<br>
정점 수: n이면 -> 간선의 수: n * (n-1) / 2<br>
<br>

## 그래프의 추상자료형
Create() : 그래프 생성<br>
Init(g) : 그래프 초기화<br>
Insert_Vertex(g, v) : 그래프에 정점 v 삽입<br>
Insert_Edge(g, u, v) : 그래프에 간선 (u,v)를 삽입<br>
Delete_Vertex(g, v) : 그래프의 정점 v 삭제<br>
Delete_Edge(g, u, v) : 그래프의 간선 (u,v)를 삭제<br>
Is_Empty(g) : 그래프가 공백 상태인지 확인<br>
Adjacent(v) : 정점 v에 인접합 정점들의 리스트를 반환<br>
<br>

## 그래프 구현 방법
**인접 행렬**<br>
2차원 배열을 이용하여 그래프를 표현<br>
그래프의 정점 수가 n이라면 n x n의 2차원 배열인 인접 행렬 M의 각 원소를 다음의 규칙에 의해 할당함으로써 그래프를 메모리에 표현할 수 있다.<br>
> if(간선(i, j)가 그래프에 존재) M[i][j] = 1<br>
> else M[i][j] = 0
<br>

* 자체 간선을 허용하지 않으므로 대각선 성분은 모두 0으로 표시된다.<br>
* 또한 무방향 그래프같은 경우 인접행렬이 대칭행렬이 되기 때문에, 배열의 상위 삼각이나 하위 삼각만 저장하여 메모리를 절약시킬 수도 있다.<br>
* 당연히 방향 그래프는 대칭이 아니다.<br>
<br>

```C
#define MAX_VERTICES 50
typedef struct Graph
{
  int n; //삽입된 정점의 개수
  int adj_mat[MAX_VERTICES][MAX_VERTICES]; //인접 행렬 - 동적 배열로 구현한다면 사용자가 정점을 삽입할 때마다 크기 조정 가능.
}Graph;
```
> 정점을 삽입하는 연산은 단순히 n을 +1 해주면 된다. 그렇게되면 인접 행렬에서 새로운 정점에 대한 인덱스를 사용 가능하다.<br>
<br>

**특징**<br>
1. 간선의 수에 무관하게 항상 n x n개의 메모리 공간을 필요로 하기 때문에, 간선이 많이 존재하는 **밀집 그래프**에는 적합하나, <br>
간선이 적은 **희소 그래프** 같은 경우에는 메모리의 낭비가 크므로 적합하지 않다.<br>
<br>

2. 인접 행렬을 이용하면 두 정점을 연결하는 간선의 존재 여부를 O(1)만에 알 수 있다는 장점이 있다.<br>
-> M[u][v]의 값을 조사하면 되기 때문임.<br>
<br>

3. 또한 정점의 차수는 인접 행렬의 행이나 열을 조사하면 알 수 있으므로 O(n)만에 알 수 있다.<br>
-> 행으로는 진출차수, 열로는 진입차수를 알 수 있다.<br>
**_이말은 즉슨 특정 노드 u에 인접한 노드들을 모두 방문하려면 adj[u][1] ~ adj[u][n]까지 순회해야 한다는 의미이다._<br>
-> 이는 O(n)으로 인접 리스트 방식에 비해 큰 비용이다** <br>
만약, 노드의 개수는 총 1억개인데 각 노드마다 연결된 간선이 많아봤자 2개인 그래프가 있다고 해보자.<br>
그렇다면, 특정 노드와 연결된 노드들이 몇 번 노드인지 확인하기 위해 총 1억 개의 노드들을 모두 확인해봐야 하는 문제가 발생하게 된다.<br>
정작 연결된 노드는 많아봤자 2개 뿐일텐데 말이다. (이러한 단점을 보완할 수 있는 연결 관계 표현 방식이 인접 리스트다.)<br>
<br>

4. 그래프에 존재하는 모든 간선의 수를 알아내려면 인접 행렬 전체를 조사해야 하므로 n^2번의 조사가 필요하게 되어 O(n^2)의 시간이 요구된다.<br>
<br>
<br>

**인접 리스트**<br>
연결 리스트를 사용하여 그래프를 표현<br>

인접 리스트는 그래프를 표현함에 있어 각각의 정점에 인접한 정점들을 연결 리스트로 표시한 것이다.<br>
각 연결 리스트의 노드들은 인접 정점을 저장하게 되며, 각 연결 리스트는 헤더 노드를 가지고 있으며 이 헤더 노드들은 배열로 구성되어 있다.<br>
따라서 정점의 번호만 알면 이 번호를 배열의 인덱스로 하여 각 정점의 연결 리스트에 쉽게 접근할 수 있다.<br>
쉽게 이해하기 위해 아래 코드를 참고하자.<br>
<br>

```C
#define MAX_VERTICES 50
typedef struct GraphNode
{
  int vertex; //정점 번호
  struct GraphNode* link; //다음 노드를 가리킬 포인터
}GraphNode;

typedef struct Graph
{
  int n; //정점의 개수
  GraphNode* adj_list[MAX_VERTICES]; //각 정점마다 인접한 정점들을 나타낼 연결리스트를 가리키고 있는 헤더 노드들이다.
}Graph;
```
<br>

**특징**<br>
1. 정점의 수가 n개이고 간선의 수가 e개인 무방향 그래프를 표시하기 위해서는 n개의 연결리스트와 n개의 헤더노드, 2e개의 노드가 필요하다.<br>
-> 따라서 인접 리스트 표현은 간선의 개수가 적은 **희소 그래프** 의 표현에 적합하다.<br>
<br>

2. 그래프에 간선 (i, j)의 존재여부나 정점 i의 차수를 알기 위해서는 인접 리스트에서의 정점 i의 연결리스트를 탐색해야 하므로 연결리스트에 있는<br>
노드의 수 만큼의 시간이 필요하다.<br> 
-> 즉 n개 정점과 e개의 간선을 가진 그래프에서 전체 간선의 수를 알아내려면 헤더 노드를 포함하여 모든 인접 리스트를 조사해야 하므로 **O(n + e)** 의 연산이 요구된다.<br>
<br>

3. 모든 노드들을 탐색하려면 간선의 인접 리스트의 경우에는 각 노드마다 연결된 노드만 확인하는 것이 가능하기 때문에, 전체 간선의 개수만큼만 확인해 볼 수가 있다.<br>
따라서, **O(E)** 의 시간복잡도를 가진다고 할 수 있다.<br>
<br>

4. 인접 리스트에도 단점이 존재한다. 노드 i와 노드 j가 연결되어 있는지 알고 싶다면 adj_list[i]의 리스트 전체를 돌며, j를 성분으로 갖는지 확인해보아야 하므로 **O(v)** 가 소요된다.<br>
<br>

메모리 사용량과 처리시간 등에서 장단점을 가지므로 문제에 적합한 표현 방법을 사용해야한다.<br>
<br>
<br>

**인접행렬 vs 인접리스트**<br>


## 그래프의 탐색
<br>


