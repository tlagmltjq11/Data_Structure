## 그래프
![그래프](https://user-images.githubusercontent.com/43705434/112331963-b4544180-8cfc-11eb-8c28-1c79f2723a69.PNG)<br>

그래프는 객체 사이의 연결 관계를 표현할 수 있는 자료 구조로 단순히 노드(n, Node)와 그 노드를 연결하는<br>
간선(e, Edge)을 하나로 모아 놓은 것이다.<br>
<br>

Ex) 지하철 노선도, 전기회로 소자, 운영체제에서 프로세스와 자원들을 그래프로 분석.. <br>
위와같은 많은 문제들은 공통적으로 객체들이 서로 연결되어 있는 구조로 표현이 가능하기에 그래프를 이용한다.<br>
<br>


✔️ **그래프와 트리의 차이**<br>
![트리와그래프차이](https://user-images.githubusercontent.com/43705434/112331961-b4544180-8cfc-11eb-8e40-2df000ffb6d7.PNG)<br>
<br>

✔️ **오일러 경로**<br>
모든 간선을 한번만 통과하면서 처음 정점으로 돌아오는 경로를 오일러 경로라고 한다.<br>
> 그래프의 모든 정점에 연결된 간선의 개수가 짝수일 때만 오일러 경로가 존재한다는 오일러의 정리를 증명함<br>

따라서 그래프는 오일러의 정리에 의해 오일러 경로가 존재하지 않는다는 것을 복잡한 시행착오 없이 손쉽게 알 수 있다.<br>
<br>

## 그래프의 정의와 용어
✔️ **그래프의 정의**<br>
그래프는 정점과 간선의 유한집합으로 **정점**은 여러가지 특성을 가질 수 있는 **객체**를 의미하고, **간선**은 이러한 정점들 간의 **관계**를 의미한다.<br>
<br>

✔️ **기본용어**<br>
* 정점(vertex): 위치라는 개념. (node 라고도 부름)<br>
* 간선(edge): 위치 간의 관계. 즉, 노드를 연결하는 선 (link, branch 라고도 부름)<br>
* 인접 정점(adjacent vertex): 간선에 의해 직접 연결된 정점<br>
* 정점의 차수(degree): 무방향 그래프에서 하나의 정점에 인접한 정점의 수<br>
* 무방향 그래프에 존재하는 정점의 모든 차수의 합 = 그래프의 간선 수의 2배 <하나의 간선이 두 정점에 연결되기 때문><br>
* 진입 차수(in-degree): 방향 그래프에서 외부에서 오는 간선의 수 (내차수 라고도 부름)<br>
* 진출 차수(out-degree): 방향 그래픙에서 외부로 향하는 간선의 수 (외차수 라고도 부름)<br>
* 방향 그래프에 있는 정점의 진입 차수 또는 진출 차수의 합 = 방향 그래프의 간선의 수(내차수 + 외차수)<br>
* 경로 길이(path length): 경로를 구성하는 데 사용된 간선의 수<br>
* 단순 경로(simple path): 경로 중에서 반복되는 정점이 없는 경우<br>
* 사이클(cycle): 단순 경로의 시작 정점과 종료 정점이 동일한 경우<br>
<br>

## 그래프의 종류
✔️ **무방향 그래프와 방향 그래프**<br>

![무방향방향그래프](https://user-images.githubusercontent.com/43705434/112331960-b3bbab00-8cfc-11eb-8ef9-79ddfbce907c.PNG)<br>
<br>

간선의 종류에 따라 그래프는 무방향, 방향으로 구분된다.<br>
<br>

무방향 그래프<br> 
무방향 그래프의 간선은 간선을 통해서 양방향으로 갈 수 있음을 나타내며 간선은 (A, B)와 같이 표현한다.<br>
<br>

방향 그래프<br>
방향 그래프는 간선에 방향성이 존재하는 그래프로서 간선을 통해 한쪽 방향으로만 갈 수 있음을 나타내며 간선을 <A, B>와 같이 표현한다.<br>
<br>

✔️ **가중치 그래프(Network)**<br>

![가중치그래프](https://user-images.githubusercontent.com/43705434/112331957-b3bbab00-8cfc-11eb-83ae-5c850f2a5bd2.PNG)<br>
<br>

간선에 비용이나 가중치가 할당된 그래프로 간선으로 연결 강도까지 나타낼 수 있어 보다 복잡한 관계를 표현할 수 있다.<br>
‘네트워크(Network)’ 라고도 한다.<br>
Ex) 도시-도시의 연결, 도로의 길이, 회로 소자의 용량, 통신망의 사용료 등<br>
<br>

✔️ **연결 그래프 VS 비연결 그래프**<br>

![연결비연결그래프](https://user-images.githubusercontent.com/43705434/112331952-b28a7e00-8cfc-11eb-93ee-26caacb8a1c7.PNG)<br>
<br>

연결 그래프(Connected Graph)<br>
무방향 그래프에 있는 모든 정점쌍에 대해서 항상 경로가 존재하는 경우<br>
Ex) 트리(Tree): 사이클을 가지지 않는 연결 그래프<br>
<br>

비연결 그래프(Disconnected Graph)<br>
무방향 그래프에서 특정 정점쌍 사이에 경로가 존재하지 않는 경우<br>
<br>

✔️ **완전 그래프**<br>

![완전그래프](https://user-images.githubusercontent.com/43705434/112331971-b61e0500-8cfc-11eb-949d-25d582909f78.png)<br>
<br>

그래프에 속해 있는 모든 정점이 서로 연결되어 있는 그래프<br>
무방향 완전 그래프<br>
정점 수: n이면 -> 간선의 수: n * (n-1) / 2<br>
<br>

## 그래프의 추상자료형
Create() : 그래프 생성<br>
Init(g) : 그래프 초기화<br>
Insert_Vertex(g, v) : 그래프에 정점 v 삽입<br>
Insert_Edge(g, u, v) : 그래프에 간선 (u,v)를 삽입<br>
Delete_Vertex(g, v) : 그래프의 정점 v 삭제<br>
Delete_Edge(g, u, v) : 그래프의 간선 (u,v)를 삭제<br>
Is_Empty(g) : 그래프가 공백 상태인지 확인<br>
Adjacent(v) : 정점 v에 인접합 정점들의 리스트를 반환<br>
<br>

## 그래프 구현 방법
✔️ **인접 행렬**<br>

![그래프인접행렬](https://user-images.githubusercontent.com/43705434/112331969-b5856e80-8cfc-11eb-9d56-4415a61e32a1.PNG)<br>
<br>

2차원 배열을 이용하여 그래프를 표현<br>
그래프의 정점 수가 n이라면 n x n의 2차원 배열인 인접 행렬 M의 각 원소를 다음의 규칙에 의해 할당함으로써 그래프를 메모리에 표현할 수 있다.<br>
> if(간선(i, j)가 그래프에 존재) M[i][j] = 1<br>
> else M[i][j] = 0
<br>

* 자체 간선을 허용하지 않으므로 대각선 성분은 모두 0으로 표시된다.<br>
* 또한 무방향 그래프같은 경우 인접행렬이 대칭행렬이 되기 때문에, 배열의 상위 삼각이나 하위 삼각만 저장하여 메모리를 절약시킬 수도 있다.<br>
* 당연히 방향 그래프는 대칭이 아니다.<br>
<br>

```C
#define MAX_VERTICES 50
typedef struct Graph
{
  int n; //삽입된 정점의 개수
  int adj_mat[MAX_VERTICES][MAX_VERTICES]; //인접 행렬 - 동적 배열로 구현한다면 사용자가 정점을 삽입할 때마다 크기 조정 가능.
}Graph;
```
> 정점을 삽입하는 연산은 단순히 n을 +1 해주면 된다. 그렇게되면 인접 행렬에서 새로운 정점에 대한 인덱스를 사용 가능하다.<br>
<br>

✔️ **특징**<br>
1. 간선의 수에 무관하게 항상 n x n개의 메모리 공간을 필요로 하기 때문에, 간선이 많이 존재하는 **밀집 그래프**에는 적합하나, <br>
간선이 적은 **희소 그래프** 같은 경우에는 메모리의 낭비가 크므로 적합하지 않다.<br>
<br>

2. 인접 행렬을 이용하면 두 정점을 연결하는 간선의 존재 여부를 **O(1)** 만에 알 수 있다는 장점이 있다.<br>
-> M[u][v]의 값을 조사하면 되기 때문임.<br>
<br>

3. 또한 정점의 차수는 인접 행렬의 행이나 열을 조사하면 알 수 있으므로 **O(n)** 만에 알 수 있다.<br>
-> 행으로는 진출차수, 열로는 진입차수를 알 수 있다.<br>
**_이말은 즉슨 특정 노드 u에 인접한 노드들을 모두 방문하려면 adj[u][1] ~ adj[u][n]까지 순회해야 한다는 의미이다._<br>
-> 이는 O(n)으로 인접 리스트 방식에 비해 큰 비용이다** <br>
만약, 노드의 개수는 총 1억개인데 각 노드마다 연결된 간선이 많아봤자 2개인 그래프가 있다고 해보자.<br>
그렇다면, 특정 노드와 연결된 노드들이 몇 번 노드인지 확인하기 위해 총 1억 개의 노드들을 모두 확인해봐야 하는 문제가 발생하게 된다.<br>
정작 연결된 노드는 많아봤자 2개 뿐일텐데 말이다. (이러한 단점을 보완할 수 있는 연결 관계 표현 방식이 인접 리스트다.)<br>
<br>

4. 그래프에 존재하는 모든 간선의 수를 알아내려면 인접 행렬 전체를 조사해야 하므로 n^2번의 조사가 필요하게 되어 **O(n^2)** 의 시간이 요구된다.<br>
<br>
<br>

✔️ **인접 리스트**<br>

**알고리즘 리포지토리의 Graph 문제풀이 폴더에 존재하는 (배열대신 List로 C# 언어에서 구현한 그래프)를 참고하고 복기하기!!**<br>
<br>

![그래프인접리스트](https://user-images.githubusercontent.com/43705434/112331973-b61e0500-8cfc-11eb-8b16-6061c4ee6cc2.PNG)<br>
<br>

연결 리스트를 사용하여 그래프를 표현<br>

인접 리스트는 그래프를 표현함에 있어 각각의 정점에 인접한 정점들을 연결 리스트로 표시한 것이다.<br>
각 연결 리스트의 노드들은 인접 정점을 저장하게 되며, 각 연결 리스트는 헤더 노드를 가지고 있으며 이 헤더 노드들은 배열로 구성되어 있다.<br>
따라서 정점의 번호만 알면 이 번호를 배열의 인덱스로 하여 각 정점의 연결 리스트에 쉽게 접근할 수 있다.<br>
쉽게 이해하기 위해 아래 코드를 참고하자.<br>
<br>

```C
#define MAX_VERTICES 50
typedef struct GraphNode
{
  int vertex; //정점 번호
  struct GraphNode* link; //다음 노드를 가리킬 포인터
}GraphNode;

typedef struct Graph
{
  int n; //정점의 개수
  GraphNode* adj_list[MAX_VERTICES]; //각 정점마다 인접한 정점들을 나타낼 연결리스트를 가리키고 있는 헤더 노드들이다.
}Graph;
```
<br>

✔️ **특징**<br>
1. 정점의 수가 n개이고 간선의 수가 e개인 무방향 그래프를 표시하기 위해서는 n개의 연결리스트와 n개의 헤더노드, 2e개의 노드가 필요하다.<br>
-> 따라서 인접 리스트 표현은 간선의 개수가 적은 **희소 그래프** 의 표현에 적합하다.<br>
<br>

2. 그래프에 간선 (i, j)의 존재여부나 정점 i의 차수를 알기 위해서는 인접 리스트에서의 정점 i의 연결리스트를 탐색해야 하므로 연결리스트에 있는<br>
노드의 수 만큼의 시간이 필요하다.<br> 
-> 즉 n개 정점과 e개의 간선을 가진 그래프에서 전체 간선의 수를 알아내려면 헤더 노드를 포함하여 모든 인접 리스트를 조사해야 하므로 **O(n + e)** 의 연산이 요구된다.<br>
<br>

3. 모든 노드들을 탐색하려면 간선의 인접 리스트의 경우에는 각 노드마다 연결된 노드만 확인하는 것이 가능하기 때문에, 전체 간선의 개수만큼만 확인해 볼 수가 있다.<br>
따라서, **O(E)** 의 시간복잡도를 가진다고 할 수 있다.<br>
<br>

4. 인접 리스트에도 단점이 존재한다. 노드 i와 노드 j가 연결되어 있는지 알고 싶다면 adj_list[i]의 리스트 전체를 돌며, j를 성분으로 갖는지 확인해보아야 하므로 **O(v)** 가 소요된다.<br>
<br>

메모리 사용량과 처리시간 등에서 장단점을 가지므로 문제에 적합한 표현 방법을 사용해야한다.<br>
<br>
<br>

✔️ **인접행렬 vs 인접리스트**<br>
인접행렬의 장점<br>
1. 구현이 쉽다.
2. 간선의 존재 여부를 O(1)에 확인할 수 있다.
3. 간선이 계속 추가되어도 추가적인 메모리가 요구되지 않는다.
<br>

인접행렬의 단점<br>
1. 메모리의 낭비가 심하다.
2. 특정 노드에 인접한 노드들을 모두 방문하는데 O(n)의 비용이 든다.
3. 모든 간선의 수를 계산하려면 행렬 전체를 순회해야 하기 때문에 O(n^2)이 소요된다.
<br>

인접리스트의 장점<br>
1. 인접 행렬과 달리 실제로 연결된 노드들에 대한 정보만 저장하기 때문에 메모리를 낭비하지 않는다.
2. 모든 노드를 탐색할때 연결된 노드만 확인할 수 있기에 전체 간선의 개수인 O(E)만에 확인이 가능하다.
3. 인접 행렬의 단점들을 극복 가능하다.
<br>

인접리스트의 단점<br>
1. 간선의 존재 여부를 확인할때 연결된 노드들을 모두 순회해야 한다.
2. 간선의 개수가 많아질수록 필요한 메모리가 비례해 증가한다.

✔️ **결론**<br>
각각의 표현 방식은 장단점이 명확하기에 문제의 상황에 따라 적절한 방식을 채택하여 사용하자.<br>
<br>

## 그래프의 탐색
그래프의 탐색이란 하나의 정점으로부터 시작하여 차례대로 모든 정점들을 한 번씩 방문하는 것이다.<br>
DFS와 BFS 모두 그래프가 인접 행렬, 인접 리스트 무엇으로 구현되었느냐에 따라서 구현 방식이 조금 달라진다.<br>
<br>

✔️ **DFS**<br>
![DFS](https://user-images.githubusercontent.com/43705434/112331966-b4ecd800-8cfc-11eb-9a0d-396c9598249a.PNG)<br>
<br>

루트 노드(혹은 다른 임의의 노드)에서 시작해서 다음 분기(branch)로 넘어가기 전에 해당 분기를 완벽하게 탐색하는 방법이다.<br>
즉, 넓게(wide) 탐색하기 전에 깊게(deep) 탐색하는 것이다.<br>
<br>

**특징**<br>
* 모든 노드를 방문 하고자 하는 경우에 이 방법을 선택한다.<br>
* 깊이 우선 탐색이 너비 우선 탐색보다 좀 더 간단하다.<br>
* 재귀나 Stack을 이용해서 구현한다.★<br>
<br>

✔️ 재귀버전<br>
```C
DFS(v):
  
  visited[v] = TRUE;
  for all u in (v에 인접한 정점) do
    if(visited[u] == FALSE)
      then DFS(u);
```
<br>

✔️ 스택버전<br>
```C
DFS(v):
  
  스택 S를 생성;
  S.Push(v);
  while (not isEmpty(S)) do //스택이 비어있지 않은 동안 반복
    v = S.Pop();
    if(v가 방문되지 않았으면)
      v를 방문되었다고 표시;
      for all u in (v에 인접한 정점) do
        if(u가 아직 방문되지 않았으면)
          S.Push(u);
```
<br>

**시간 복잡도 분석**<br>
DFS는 모든 간선을 조사하므로 정점의 수가 n이고 간선의 수가 e인 경우, 인접 리스트로 표현된 그래프라면 **O(n+e)** 이며<br>
인접 행렬로 표현된 그래프라면 **O(n^2)** 이다. 이는 희소 그래프인 경우 DFS는 인접 리스트의 사용이 인접 행렬보다 시간적으로 <br>
유리함을 뜻한다.<br>
<br>

✔️ **BFS**<br>
![BFS](https://user-images.githubusercontent.com/43705434/112331967-b4ecd800-8cfc-11eb-9577-e2653e373951.PNG)<br>
<br>

루트 노드(혹은 다른 임의의 노드)에서 시작해서 인접한 노드를 먼저 탐색하는 방법이다.<br>
즉, 깊게(deep) 탐색하기 전에 넓게(wide) 탐색하는 것이다.<br>
<br>

**특징**<br>
* 두 노드 사이의 최단 경로 혹은 임의의 경로를 찾고 싶을 때 이 방법을 선택한다.<br>
Ex) 지구상에 존재하는 모든 친구 관계를 그래프로 표현한 후 Ash와 Vanessa 사이에 존재하는 경로를 찾는 경우<br>
* 모든 노드를 방문하려는 DFS보다 속도가 빠르다.<br>
* 큐를 이용해서 구현한다.★<br>
<br>

**BFS는 가중치가 없는 그래프에서만 최단 경로를 찾아 줄 수 있다는 점을 유의해야 한다.<br>
우선 BFS는 자신과 바로 연결되어 있는 노드들을 큐에 넣는다. <br>
그리고 큐는 FIFO에 따라서 가장 먼저들어온 것들을 가장먼저 처리한다.<br>
이 두 개의 특성이 결합돼서 시작지점으로부터 간선의 수가 작은 곳 부터 먼저 처리되게 된다.<br>
따라서 간선 2개로 도달할 수 있는 노드가 간선 1개로 도달할 수 있는 노드보다 큐에 먼저 들어오는 일은 발생하지 않는다.<br>
이와 같은 특성을 통해서 가중치가 없는 그래프내에서 최단경로와 거리를 찾을 수 있는 것이다.**<br>
<br>
<br>

![bfs최단경로](https://user-images.githubusercontent.com/43705434/113827085-dac6b200-97bd-11eb-9fb9-28ba1cc7abaf.PNG)<br>
**하지만 가중치가 존재한다면 다익스트라나 다른 알고리즘을 사용해야하는데 위 그림에서 나타내는 그래프가 위에서 말한 상황을 표현한다.<br> 
이 그래프는 BFS 로는 0번 정점에서 2번 정점으로 가는 최단경로를 찾을 수 없다. 0번 정점에서 2번 정점으로 가는 최단 경로는 우리 눈으로<br>
쉽게 볼 수 있듯, 0→1→3→2 이지만, BFS가 방문하는 순서는, 0→(1,2 번 정점 방문)→3 이기 때문에, BFS로는 해결할 수 없는것이 확실하다.<br>
간선이 좀 더 늦게 발견되어도, 길이(가중치)가 짧다면 발견된 순서를 좀 무시하고 "새치기"할 필요가 있음을 알 수 있다. 이러한 아이디어에서<br>
우선순위 큐를 활용하는 다익스트라 알고리즘이 파생되었다고 볼 수 있다.**<br>
<br>

**tip.**<br>
1) 경로의 특징을 저장해둬야 하는 문제<br>
예를 들면 각 정점에 숫자가 적혀있고 a부터 b까지 가는 경로를 구하는데 경로에 같은 숫자가 있으면 안 된다는 문제 등,<br>
각각의 경로마다 특징을 저장해둬야 할 때는 DFS를 사용한다. (BFS는 경로의 특징을 가지지 못함)<br>
<br>

2) 최단거리 구해야 하는 문제<br>
미로 찾기 등 최단거리를 구해야 할 경우, BFS가 유리하다.<br>
왜냐하면 깊이 우선 탐색으로 경로를 검색할 경우 처음으로 발견되는 해답이 최단거리가 아닐 수 있지만, <br>
너비 우선 탐색으로 현재 노드에서 가까운 곳부터 찾기 때문에경로를 탐색 시 먼저 찾아지는 해답이 곧 최단거리기 때문이다.<br>
<br>

✔️ 큐로 구현<br>
```C
BFS(v):
  
  v를 방문되었다고 표시;
  큐 Q에 정점 v를 삽입;
  while( Q가 공백이 아니라면 ) do
    Q에서 정점 w를 삭제;
    for all u in (w에 인접한 정점) do
      if(u가 아직 방문되지 않았다면)
        then u를 큐에 삽입;
          u를 방문되었다고 표시;
```
<br>

**시간 복잡도 분석**<br>
BFS는 그래프가 인접 리스트로 구현되어있는 경우 전체 수행시간이 **O(n + e)** 이며, 인접 행렬로 구현되어 있는 경우<br>
**O(n^2)** 시간이 걸린다. DFS와 같이 희소 그래프를 사용할 경우 인접 리스트를 사용하는 것이 효율적이다.<br>
<br>

✔️ **DFS vs BFS**<br>
해당 문제에 따라서 적절하게 채택하여 사용하면 되는데, 보통 DFS는 이동한 정점의 값을 가지고 계속 연산을 하는 경우에 사용한다.<br>
BFS는 최단경로를 구하는데 자주 사용된다.<br>
<br>


