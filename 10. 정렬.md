## 정렬
![정렬](https://user-images.githubusercontent.com/43705434/112807483-ea097980-90b2-11eb-978a-52d072c17b37.PNG)<br>
<br>

정렬은 물건을 크기순으로 오름차순이나 내림차순으로 나열하는 것을 의미한다.<br>
컴퓨터나 인간이나 정렬되어 있지 않은 자료 속에서 무엇인가를 탐색한다는 것은 굉장히 비효율적이다.<br>
그러므로 자료 탐색에 있어서 정렬은 필수적이고 중요한 요소이다.<br>
<br>

개발된 정렬 알고리즘은 매우 많지만, 아직까지도 모든 경우에 있어서 최상의 성능을 보여주는 최적 알고리즘은 존재하지 않는다.<br>
고로 문제에 걸맞는 알고리즘을 채택하여 사용하여야 한다.<br>
<br>

## 정렬 알고리즘 분류

✔️ **단순하지만 비효율적인 알고리즘**<br>
1. 삽입 정렬
2. 선택 정렬
3. 버블 정렬
4. 쉘 정렬
등..
<br>

✔️ **복잡하지만 효율적인 알고리즘**<br>
1. 퀵 정렬
2. 히프 정렬
3. 합병 정렬
4. 기수 정렬
등..
<br>

대개 자료의 개수가 적다면 구현이 단순한 정렬 방법을 사용하는 것도 괜찮지만 자료의 개수가 일정 개수를<br>
넘어가게되면 반드시 효율적인 알고리즘을 사용해야 한다.<br>
<br>

✔️ **안정성**<br>
정렬 알고리즘들을 안정성이라는 기준으로 분류할 수도 있는데, 이는 데이터에 동일한 키값을 갖는 레코드가 여럿 존재할 경우<br>
이 레코드들의 상대적인 위치가 정렬 후에도 바뀌지 않음을 뜻한다.<br>
**삽입정렬, 버블정렬, 합병정렬** 등이 안정성을 충족한다.<br>
<br>

## 선택 정렬
추가 메모리를 요구하지 않는 제자리 정렬(in-place sorting) 알고리즘의 하나로 해당 순서에<br> 
원소를 넣을 위치는 이미 정해져 있고, 어떤 원소를 넣을지 선택하는 알고리즘이다.<br>
<br>

✔️ **알고리즘(오름차순) 단계**<br>
1. 첫 번째 위치에 가장 최솟값을 넣는다.
2. 두 번째 위치에 남은 값 중에서의 최솟값을 넣는다.
3. 위 과정을 n-2번 반복한다.
<br>

![선택정렬과정](https://user-images.githubusercontent.com/43705434/112806250-8d598f00-90b1-11eb-9817-42191cfea99a.PNG)<br>
<br>

**선택 정렬의 분석**<br>
<br>

✔️ **시간복잡도**<br>
최선, 평균, 최악 모두 시간복잡도는 **O(n^2)** 이다.<br>

✔️ **장점**<br>
1. 알고리즘이 단순하다.
2. 정렬을 위한 비교 횟수는 많지만, 거품정렬(Bubble Sort)에 비해 실제로 교환하는 횟수는 적기 때문에 많은 교환이 일어나야 하는 자료상태에서 비교적 효율적이다.
3. 거품정렬(Bubble Sort)와 마찬가지로 정렬하고자 하는 배열 안에서 교환하는 방식(제자리 정렬, In-place Sort)이므로, 다른 메모리 공간을 필요로 하지 않는다.
<br>

✔️ **단점**<br>
1. 시간복잡도가 O(n^2)으로, 비효율적이다.
2. 불안정 정렬(Unstable Sort) 이다. -> 상대적 위치가 바뀐다.
<br>
<br>

## 삽입 정렬
삽입 정렬은 손안의 카드를 정렬하는 방법과 유사하다. 카드들을 올바른 자리를 찾아 삽입하는 것 처럼 정렬을 수행하는데 입력배열을<br>
정렬된 부분과 정렬되지 않은 부분으로 나누어 사용한다. 두 번째 자료부터 시작해 그 앞(왼쪽)의 자료들과 비교하여<br>
삽입할 위치를 지정한 후 자료를 뒤로 옮기고 지정한 자리에 자료를 삽입하여 정렬하는 알고리즘이다.<br>
<br>

✔️ **알고리즘 단계**<br>
1. 두 번째 데이터 부터 정렬되지 않은 부분으로 여기고 하나씩 선택한다.
2. 선택된 데이터를 앞쪽의 정렬된 부분에 속하는 데이터들과 역순으로 비교해가며 자리를 찾을때까지 기존 데이터를 뒤로 미룬다.
3. 자리를 찾게되면 해당 위치에 데이터를 삽입한다.
4. 정렬이 완료될때까지 반복한다.
<br>

![삽입정렬과정](https://user-images.githubusercontent.com/43705434/112806252-8d598f00-90b1-11eb-8522-6d7d9bc6908e.PNG)<br>
<br>

**삽입 정렬의 분석**<br>

✔️ **시간복잡도**<br>
* 최선의 경우 (이미 정렬되어있는 경우)<br>
이미 정렬이 되어있다면 현재 위치가 삽입되어야 할 위치이기 때문에 바로 앞 데이터와의 비교 1번만 필요하게 된다.<br>
고로 외부 루프 (n-1)을 미루어 보아 **O(n)** 안에 해결이 된다.<br>
<br>

* 최악의 경우 (역순일 경우)<br>
각 단계에서 앞에 놓인 자료들을 전부 한칸씩 뒤로 미루어주고 삽입해야 하기 때문에 **O(n^2)** 이 소요된다.<br>
<br>

✔️ **장점**<br>
1. 알고리즘이 단순하다.
2. 대부분위 레코드가 이미 정렬되어 있는 경우에 매우 효율적일 수 있다.
3. (제자리 정렬, In-place Sort)이므로, 다른 메모리 공간을 필요로 하지 않는다.
4. 안정성을 제공한다.
5. 버블정렬에 비해 비교횟수가 적다.
<br>

✔️ **단점**<br>
1. 시간복잡도가 O(n^2)으로, 비효율적이다.
2. 비교적 많은 레코드들의 이동을 포함한다. -> 레코드의 양이 많고 크기가 클 경우 부적합하다.
<br>
<br>

## 버블 정렬
버블 정렬은 인접한 2개의 레코드를 비교하여 크기가 순서대로 되어 있지 않으면 서로 교환하는 비교-교환 과정을<br>
리스트의 왼쪽 끝에서 오른쪽 끝까지 진행한다. 이러한 과정이 완료되면 가장 큰 데이터가 오른쪽 끝으로 이동되어 있을 것이다.<br>
고로 해당 과정을 전체 데이터가 정렬될 때 까지 진행하면 된다.<br>
<br>

✔️ **알고리즘 단계**<br>
1. 인접한 2개의 데이터를 비교한다.
2. 순서대로 되어있지 않다면 교환한다.
3. 다음 인덱스로 넘어간다.
4. 1~3 과정을 리스트의 끝까지 진행한다.
5. 4 과정을 전체가 정렬될 때 까지 진행한다. 
<br>

![버블정렬과정](https://user-images.githubusercontent.com/43705434/112806248-8cc0f880-90b1-11eb-95ac-4793d2002c4a.PNG)<br>
<br>

**버블 정렬의 분석**<br>

✔️ **시간복잡도**<br>
최선, 평균, 최악 모두 시간복잡도는 **O(n^2)** 이다.<br>
<br>

✔️ **장점**<br>
1. 알고리즘이 매우 단순하다.
<br>

✔️ **단점**<br>
1. 시간복잡도가 O(n^2)으로, 비효율적이다.
2. 하나의 요소가 가장 왼쪽에서 가장 오른쪽으로 이동하기 위해서는 배열에서 모든 다른 요소들과 교환되어야 한다.
3. **일반적으로 자료의 교환 작업이 자료의 이동 작업보다 더 복잡하기 때문에 버블 정렬은 단순성에도 불구하고 거의 쓰이지 않는다.**
<br>
<br>

## 셸(shell) 정렬
삽입 정렬이 어느 정도 정렬된 배열에 대해서는 대단히 빠른 것에 착안해 이를 보완하여 개발한 알고리즘이다.<br>
삽입 정렬의 최대 문제점은 요소들이 삽입될 때 이웃한 위치로만 이동한다는 점이었다.<br>
즉, 만약 삽입되어야 할 위치가 현재 위치에서 상당히 멀리 떨어진 곳이라면 많은 이동을 해야만 제자리로 갈 수 있었다.<br>
그리하여 삽입 정렬과 다르게 셸 정렬은 전체의 리스트를 한 번에 정렬하지 않고, 리스트를 일정한 기준에 따라<br>
분류하여 여러개의 리스트로 만든 후 각 부분 리스트를 삽입정렬로 정렬하며 해당 과정을 리스트를 나누는 간격을 줄여나가며<br>
부분 리스트의 개수가 1이 될때까지 반복하여 최종 정렬을 수행한다.<br>
<br>

✔️ **알고리즘 단계**<br>
1. 먼저 정렬해야 할 리스트를 일정한 기준에 따라 분류
2. 연속적이지 않은 여러 개의 부분 리스트를 생성
3. 각 부분 리스트를 삽입 정렬을 이용하여 정렬
4. 모든 부분 리스트가 정렬되면 다시 전체 리스트를 더 적은 개수의 부분 리스트로 만든 후에 알고리즘을 반복
5. 위의 과정을 부분 리스트의 개수가 1이 될 때까지 반복
<br>

✔️ **tip.**<br>
1. 첫 간격은 n/2로 하는것이 대부분이며 단계마다 간격을 절반으로 줄이는 방식을 많이 사용한다.
2. 만약 간격이 짝수이면 1을 더하는 것이 좋은 것으로 분석되었다.
3. 생성된 부분 리스트의 개수는 gap(간격)과 동일하다.
<br>

![셸정렬과정](https://user-images.githubusercontent.com/43705434/112806247-8cc0f880-90b1-11eb-9f11-f6d57ae26d18.PNG)<br>
<br>

**셸 정렬의 분석**<br>

✔️ **시간복잡도**<br>
평균: O(n^1.5)<br>
최악의 경우: O(n^2)<br>
<br>

✔️ **장점**<br>
1. 연속적이지 않은 부분 리스트에서 자료의 교환이 일어나면 더 큰 거리를 이동한다. -> 따라서 교환되는 요소들이 삽입 정렬보다는 최종 위치에 있을 가능성이 높아진다.
2. 부분 리스트는 어느 정도 정렬이 된 상태이기 때문에 셸 정렬은 기본적으로 삽입 정렬을 수행하는 것이지만 삽입 정렬이 정렬된 리스트에 효율적인 점을 이용해 더욱 빠르게 수행된다.
3. 알고리즘이 간단하여 프로그램으로 쉽게 구현할 수 있다.
<br>

✔️ **단점**<br>
1. 일정한 간격에 따라서 배열을 바라봐야 한다. 즉, 이 '간격'을 잘못 설정한다면 성능이 굉장히 안 좋아질수 있다.
<br>
<br>

## 합병(merge) 정렬
합병 정렬은 **분할 정복** 기법에 기반한 정렬 알고리즘으로 정렬할 리스트를 균등한 크기로 더이상 나눌 수 없을 때까지<br>
나눈 후 해당 리스트들을 합병하며 정렬하는 방식이다. 물론 분할 정복에 기반했기 때문에 재귀적으로 구현된다.<br>
<br> 

✔️ **전체 알고리즘 단계**<br>
1. 정렬되지 않은 리스트를 두 개의 균등한 크기로 분할한다.
2. 1번 과정을 더이상 분할 할 수 없을때까지 반복한다.
3. 분할된 각 리스트를 정렬과 함께 합병한다.
4. 모든 리스트들이 합병될 때 까지 진행한다.
<br>

![병합정렬전체](https://user-images.githubusercontent.com/43705434/112806241-8c286200-90b1-11eb-9049-282edb5e9201.PNG)<br>
<br>

✔️ **합병 알고리즘 단계**<br>
합병 정렬에서 실질적으로 정렬이 되는 시점은 분할 후가 아니라 합병되는 시점이기 때문에<br>
합병 알고리즘이 가장 중요하다. 이러한 알고리즘은 다음과 같이 진행된다.<br>
1. 2개의 리스트의 값들을 처음부터 하나씩 비교하여 두 개의 리스트의 값 중에서 더 작은 값을 새로운 리스트(sorted)로 옮긴다.
2. 둘 중에서 하나가 끝날 때까지 이 과정을 되풀이한다.
3. 만약 둘 중에서 하나의 리스트가 먼저 끝나게 되면 나머지 리스트의 값들을 전부 새로운 리스트(sorted)로 복사한다.
4. 새로운 리스트(sorted)를 원래의 리스트(list)로 옮긴다.
<br>

**이때 각 리스트들은 어느정도 정렬된 상태이기에 각 리스트의 맨 처음 요소들을 비교하는 것 만으로 충분히 더 작은 값을 찾을 수 있다.**<br>
<br>

![병합정렬머지과정](https://user-images.githubusercontent.com/43705434/112806243-8c286200-90b1-11eb-81ae-17de55355f58.PNG)<br>
<br>

**합병 정렬의 분석**<br>

✔️ **시간복잡도**<br>
데이터의 종류나 분포에 영향을 받지 않기 때문에 최선, 평균, 최악 모두 **O(nlogn)** 이 소요된다.<br>
<br>

✔️ **장점**<br>
1. 시간복잡도 측면에서 효율적인 알고리즘이다.
2. 안정성을 제공한다.
3. 데이터의 분포나 종류에 영향을 받지 않는다.
<br>

✔️ **단점**<br>
1. 임시 배열이 필요하므로 추가적인 메모리를 사용해야한다. (제자리 정렬이 아님)
2. 만약 레코드들의 크기가 큰 경우 이동횟수가 많으므로 시간적 낭비를 초래할 수 있다.
-> **하지만 레코드를 연결리스트로 구성한다면 링크만 변경해줌으로써 데이터의 이동은 무시할 수 있다. 
고로 합병 정렬은 레코드에 연결리스트를 사용한다면 퀵 정렬을 포함한 다른 어떤 정렬 방법보다 효율적일 수 있다.**<br>
<br>

[시간복잡도](https://devlimk1.tistory.com/138)<br>
<br>
<br>

## 퀵 정렬
분할 정복 알고리즘의 하나로, 평균적으로 매우 빠른 수행 속도를 자랑하는 정렬 방법이다.<br> 
합병 정렬(merge sort)과 달리 퀵 정렬은 피벗을 이용해서 리스트를 비균등하게 분할한다.<br> 
<br> 

✔️ **전체 알고리즘 단계**<br>
1. 리스트 안에 있는 한 요소를 선택한다. 이렇게 고른 원소를 피벗(pivot) 이라고 한다.
2. 피벗을 기준으로 피벗보다 작은 요소들은 모두 피벗의 왼쪽으로 옮기고 피벗보다 큰 요소들은 모두 피벗의 오른쪽으로 옮긴다. 
3. 피벗을 제외한 왼쪽 리스트와 오른쪽 리스트에 대해서 재귀를 통해 다시 정렬을 수행한다.
4. 1~3번 과정을 더이상 리스트를 분할 할 수 없을 때까지 진행한다.
<br>

![퀵소트전체과정](https://user-images.githubusercontent.com/43705434/112806236-8b8fcb80-90b1-11eb-9f94-bb01bcfa35e1.PNG)<br>
<br>

✔️ **Partition 알고리즘 단계**<br>
퀵 정렬에서 가장 핵심적인 내용은 파티션 메소드를 통해 피벗의 위치를 결정짓는 것이기 때문에 해당 알고리즘을<br>
단계로 알아보도록 한다.<br>
1. pivot 값을 리스트의 첫번째 요소로 지정한다. (물론 다른 값으로 지정해도 된다.)
2. low, high 2개의 인덱스 변수를 이용해서 리스트를 2 부분으로 나누는데 과정은 아래와 같다.
3. low는 왼쪽에서 오른쪽으로 탐색해가다가 피벗보다 큰 데이터를 찾으면 멈춘다.
4. high는 오른쪽에서 왼쪽으로 탐색해가다가 피벗보다 작은 데이터를 찾으면 멈춘다.
5. low와 high가 가리키는 두 데이터를 서로 교환한다.
6. 이 탐색-교환 과정은 low와 high가 엇갈릴 때까지 반복한다.
7. low와 high가 엇갈리게되면 리스트를 성공적으로 pivot 값을 기준으로 나눈것이 된다.
8. 이제 피벗의 위치를 제위치 시키기 위해 list[left] (피벗)와 list[high]를 교환한다.
9. high 즉 피벗의 위치를 반환한다.
<br>

![퀵소트파티션](https://user-images.githubusercontent.com/43705434/112806233-8b8fcb80-90b1-11eb-9574-20d6c79d4623.PNG)<br>
<br>

**퀵 정렬의 분석**<br>

✔️ **시간복잡도**<br>
최선 및 평균 : O(nlogn)<br>
최악(정렬된 경우) : O(n^2)<br>
**정렬된(역순포함) 배열에서 바로 피봇을 최솟값이나 최댓값으로 선택한 경우에 가장 큰 시간이 소요된다.** <br>
-> 이를 해결하기 위해서 피벗을 정할때 보다 리스트의 중앙 부분을 분할 할 수 있도록 데이터를 선택해야 한다.<br>
-> 많이 사용되는 방법은 리스트 내의 몇 개의 데이터 중에서 중간값을 피벗으로 선택하는 것이다.<br>
-> 일반적으로 왼쪽, 오른쪽, 중간의 3개의 데이터 중에서 중간 값을 선택한다.<br>
<br>

✔️ **장점**<br>
1. 시간 복잡도가 O(nlog₂n)를 가지는 다른 정렬 알고리즘과 비교했을 때도 가장 빠르다.<br>
**-> 이러한 이유는 불필요한 데이터의 이동을 줄이고 먼 거리의 데이터를 교환할 뿐만아니라,<br>
한번 결정된 기준은 추후 연산에서 제외되는 성질을 가지기 때문이다.**<br>
2. 제자리 정렬이 가능하다.
<br>

✔️ **단점**<br>
1. 정렬된 리스트에 대해서는 퀵 정렬의 불균형 분할에 의해 오히려 수행시간이 더 많이 걸린다.
<br>
<br>

## 히프 정렬
최대 힙 트리나 최소 힙 트리를 구성해 정렬을 하는 방법이다.<br>
내림차순 정렬을 위해서는 최대 힙을 구성하고 오름차순 정렬을 위해서는 최소 힙을 구성하면 된다.<br>
<br>

✔️ **알고리즘(오름차순) 단계**<br>
1. 정렬해야 할 n개의 요소들로 최대 힙을 만든다.
2. 한 번에 하나씩 요소를 힙에서 꺼내서 배열의 뒤부터 저장하면 된다.
3. 삭제되는 요소들(최댓값부터 삭제)은 값이 감소되는 순서로 정렬되게 된다.
<br>

![힙정렬과정](https://user-images.githubusercontent.com/43705434/112806232-8af73500-90b1-11eb-9dfc-6bdef8e4ff54.PNG)<br>
<br>

**히프 정렬의 분석**<br>

✔️ **시간복잡도**<br>
평균 : O(nlogn)<br>
<br>

✔️ **장점**<br>
1. 시간 복잡도가 O(nlog₂n)으로 빠르다.
2. 제자리 정렬이 가능하다.
3. 특정 값 몇개만 정렬하고자 할때 효율적이다.
<br>

✔️ **단점**<br>
1. 데이터들의 상태에 따라 다른 정렬법들에 비해서 조금 느린편이다.
2. 안정성을 제공하지 못한다.
<br>
<br>

## 기수 정렬
Counting 정렬과 마찬가지로 O(n)의 속도로 굉장히 빠른 정렬방법이다.<br>
비교(Comparison)을 하지 않고 자리수 큐에 데이터를 넣었다 뺐다 하면서 정렬을 진행한다.<br>
하지만 양의 정수끼리 혹은 음의 정수끼리 등 제한적인 데이터만 (실수에서는 불가) 사용이 가능하다.<br>
<br>

✔️ **알고리즘(오름차순) 단계**<br>
그림으로 대체<br>

![기수정렬1](https://user-images.githubusercontent.com/43705434/112806230-8af73500-90b1-11eb-882d-03c27b7a8243.PNG)<br>
![기수정렬2](https://user-images.githubusercontent.com/43705434/112806226-89c60800-90b1-11eb-9f7b-f753121347e5.PNG)<br>
<br>

사진<br>
<br>

**기수 정렬의 분석**<br>

✔️ **시간복잡도**<br>
평균 : O(n)<br>
<br>

✔️ **장점**<br>
1. 굉장히 빠르다. O(nlogn)의 하한선을 깰 수 있는 유일한 기법이다.
<br>

✔️ **단점**<br>
1. 레코드의 특성에 따라 사용 가능여부가 갈린다.
2. 추가적인 메모리를 요구한다.
<br>
<br>

## 정렬 알고리즘의 비교

✔️ 알고리즘의 시간복잡도 비교<br>

![알고리즘시간복잡도비교](https://user-images.githubusercontent.com/43705434/112806255-8df22580-90b1-11eb-83b2-81b6a56bb19d.PNG)<br>
<br>

✔️ 알고리즘의 장단점 비교<br>

![정렬알고장단점비교](https://user-images.githubusercontent.com/43705434/112806256-8df22580-90b1-11eb-8bb2-1f7fe824a524.PNG)<br>
<br>

