## 정렬
정렬은 물건을 크기순으로 오름차순이나 내림차순으로 나열하는 것을 의미한다.<br>
컴퓨터나 인간이나 정렬되어 있지 않은 자료 속에서 무엇인가를 탐색한다는 것은 굉장히 비효율적이다.<br>
그러므로 자료 탐색에 있어서 정렬은 필수적이고 중요한 요소이다.<br>
<br>

개발된 정렬 알고리즘은 매우 많지만, 아직까지도 모든 경우에 있어서 최상의 성능을 보여주는 최적 알고리즘은 존재하지 않는다.<br>
고로 문제에 걸맞는 알고리즘을 채택하여 사용하여야 한다.<br>
<br>

## 정렬 알고리즘 분류

**단순하지만 비효율적인 알고리즘**<br>
1. 삽입 정렬
2. 선택 정렬
3. 버블 정렬
4. 쉘 정렬
등..
<br>

**복잡하지만 효율적인 알고리즘**<br>
1. 퀵 정렬
2. 히프 정렬
3. 합병 정렬
4. 기수 정렬
등..
<br>

대개 자료의 개수가 적다면 구현이 단순한 정렬 방법을 사용하는 것도 괜찮지만 자료의 개수가 일정 개수를<br>
넘어가게되면 반드시 효율적인 알고리즘을 사용해야 한다.<br>
<br>

**안정성**<br>
정렬 알고리즘들을 안정성이라는 기준으로 분류할 수도 있는데, 이는 데이터에 동일한 키값을 갖는 레코드가 여럿 존재할 경우<br>
이 레코드들의 상대적인 위치가 정렬 후에도 바뀌지 않음을 뜻한다.<br>
**삽입정렬, 버블정렬, 합병정렬** 등이 안정성을 충족한다.<br>
<br>

## 선택 정렬
추가 메모리를 요구하지 않는 제자리 정렬(in-place sorting) 알고리즘의 하나로 해당 순서에<br> 
원소를 넣을 위치는 이미 정해져 있고, 어떤 원소를 넣을지 선택하는 알고리즘이다.<br>
<br>

**알고리즘(오름차순) 단계**<br>
1. 첫 번째 위치에 가장 최솟값을 넣는다.
2. 두 번째 위치에 남은 값 중에서의 최솟값을 넣는다.
3. 위 과정을 n-2번 반복한다.
<br>

사진<br>
<br>

**선택 정렬의 분석**<br>
<br>

**시간복잡도**<br>
이중 for문을 통해 진행되므로 최선, 평균, 최악 시간복잡도는 **O(n^2)** 이다.<br>
<br>

**장점**<br>
1. 알고리즘이 단순하다.
2. 정렬을 위한 비교 횟수는 많지만, 거품정렬(Bubble Sort)에 비해 실제로 교환하는 횟수는 적기 때문에 많은 교환이 일어나야 하는 자료상태에서 비교적 효율적이다.
3. 거품정렬(Bubble Sort)와 마찬가지로 정렬하고자 하는 배열 안에서 교환하는 방식(제자리 정렬, In-place Sort)이므로, 다른 메모리 공간을 필요로 하지 않는다.
<br>

**단점**<br>
1. 시간복잡도가 O(n^2)으로, 비효율적이다.
2. 불안정 정렬(Unstable Sort) 이다. -> 상대적 위치가 바뀐다.
<br>
<br>

## 삽입 정렬
삽입 정렬은 손안의 카드를 정렬하는 방법과 유사하다. 카드들을 올바른 자리를 찾아 삽입하는 것 처럼 정렬을 수행하는데 입력배열을<br>
정렬된 부분과 정렬되지 않은 부분으로 나누어 사용한다. 두 번째 자료부터 시작해 그 앞(왼쪽)의 자료들과 비교하여<br>
삽입할 위치를 지정한 후 자료를 뒤로 옮기고 지정한 자리에 자료를 삽입하여 정렬하는 알고리즘이다.<br>
<br>

**알고리즘 단계**<br>
1. 두 번째 데이터 부터 정렬되지 않은 부분으로 여기고 하나씩 선택한다.
2. 선택된 데이터를 앞쪽의 정렬된 부분에 속하는 데이터들과 역순으로 비교해가며 자리를 찾을때까지 기존 데이터를 뒤로 미룬다.
3. 자리를 찾게되면 해당 위치에 데이터를 삽입한다.
4. 정렬이 완료될때까지 반복한다.
<br>

사진<br>
<br>

**삽입 정렬의 분석**<br>
<br>

**시간복잡도**<br>
* 최선의 경우 (이미 정렬되어있는 경우)<br>
이미 정렬이 되어있다면 현재 위치가 삽입되어야 할 위치이기 때문에 바로 앞 데이터와의 비교 1번만 필요하게 된다.<br>
고로 외부 루프 (n-1)을 미루어 보아 **O(n)** 안에 해결이 된다.<br>
<br>

* 최악의 경우 (역순일 경우)<br>
각 단계에서 앞에 놓인 자료들을 전부 한칸씩 뒤로 미루어주고 삽입해야 하기 때문에 **O(n^2)** 이 소요된다.<br>
<br>

**장점**<br>
1. 알고리즘이 단순하다.
2. 대부분위 레코드가 이미 정렬되어 있는 경우에 매우 효율적일 수 있다.
3. (제자리 정렬, In-place Sort)이므로, 다른 메모리 공간을 필요로 하지 않는다.
4. 안정성을 제공한다.
5. 버블정렬에 비해 비교횟수가 적다.
<br>

**단점**<br>
1. 시간복잡도가 O(n^2)으로, 비효율적이다.
2. 비교적 많은 레코드들의 이동을 포함한다. -> 레코드의 양이 많고 크기가 클 경우 부적합하다.
<br>
<br>

## 삽입 정렬
삽입 정렬은 손안의 카드를 정렬하는 방법과 유사하다. 카드들을 올바른 자리를 찾아 삽입하는 것 처럼 정렬을 수행하는데 입력배열을<br>
정렬된 부분과 정렬되지 않은 부분으로 나누어 사용한다. 두 번째 자료부터 시작해 그 앞(왼쪽)의 자료들과 비교하여<br>
삽입할 위치를 지정한 후 자료를 뒤로 옮기고 지정한 자리에 자료를 삽입하여 정렬하는 알고리즘이다.<br>
<br>

**알고리즘 단계**<br>
1. 두 번째 데이터 부터 정렬되지 않은 부분으로 여기고 하나씩 선택한다.
2. 선택된 데이터를 앞쪽의 정렬된 부분에 속하는 데이터들과 역순으로 비교해가며 자리를 찾을때까지 기존 데이터를 뒤로 미룬다.
3. 자리를 찾게되면 해당 위치에 데이터를 삽입한다.
4. 정렬이 완료될때까지 반복한다.
<br>

사진<br>
<br>

**삽입 정렬의 분석**<br>
<br>

**시간복잡도**<br>
* 최선의 경우 (이미 정렬되어있는 경우)<br>
이미 정렬이 되어있다면 현재 위치가 삽입되어야 할 위치이기 때문에 바로 앞 데이터와의 비교 1번만 필요하게 된다.<br>
고로 외부 루프 (n-1)을 미루어 보아 **O(n)** 안에 해결이 된다.<br>
<br>

* 최악의 경우 (역순일 경우)<br>
각 단계에서 앞에 놓인 자료들을 전부 한칸씩 뒤로 미루어주고 삽입해야 하기 때문에 **O(n^2)** 이 소요된다.<br>
<br>

**장점**<br>
1. 알고리즘이 단순하다.
2. 대부분위 레코드가 이미 정렬되어 있는 경우에 매우 효율적일 수 있다.
3. (제자리 정렬, In-place Sort)이므로, 다른 메모리 공간을 필요로 하지 않는다.
4. 안정성을 제공한다.
5. 버블정렬에 비해 비교횟수가 적다.
<br>

**단점**<br>
1. 시간복잡도가 O(n^2)으로, 비효율적이다.
2. 비교적 많은 레코드들의 이동을 포함한다. -> 레코드의 양이 많고 크기가 클 경우 부적합하다.
<br>
<br>
