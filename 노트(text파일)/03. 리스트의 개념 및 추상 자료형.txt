▶ 리스트의 개념 
리스트란 자료를 순서대로 저장하는 자료구조를 의미한다. -> 구조가 단순함.
이때 여러 자료들은 서로 선형으로 연결되어있는 구조다. <앞뒤 관계가 1:1>


▶ Array vs Array List (배열을 이용해 구현한 리스트) 
중간에있는 데이터가 삭제되었다면, 배열은 상관없겠지만 배열리스트는 선형적으로 모든 데이터가
연결되어있어야 하기 때문에, 해당 빈공간만큼 앞으로 앞당겨줘 연결시켜줘야한다.
또한 추가할때에는 뒤로 밀어줘야한다.

큰 차이점 : 배열리스트는 동적으로 메모리를 늘리고 줄일 수 있다. 하지만 배열은 정적으로 런타임중
메모리를 변경할 수 없다.
또한 배열리스트는 중간에 요소를 삽입 삭제하는것이 가능하다. 배열은 그저 overwirte일뿐임.

결론적으로 ArrayList는 배열을 이용해 만든 리스트로 인덱스를 사용하기 때문에 검색이 빠르며, 배열과 달리
동적으로 메모리를 변경할 수 있다. 단, 데이터의 삽입 및 삭제시 데이터들을 밀거나 당겨줘야하기 때문에 속도가 느리다.★★


▶ Array vs LinkedList 
배열 : 연속적으로 메모리 공간을 차지, 정적
링크드리스트 : 불연속적으로 메모리 공간을 차지, 동적

장점★ : 즉 링크드리스트는 동적으로 메모리를 할당 할 수 있고, 포인터를 이용하기때문에 
불연속적으로 메모리 공간을 차지하므로 메모리의 관리 및 재사용이 편리하고 삽입 삭제가 용이하다

단점★ : 포인터를 이용하기 때문에, 다음 데이터를 가르킬 추가적인 메모리 공간이 발생된다
또한 검색 성능이 좋지 않다.

고로 데이터의 크기가 정해져있지 않고, 삽입 삭제가 많이 일어나며 검색이 적은 경우에는 링크드리스트가
유리하며, 데이터의 크기가 정해져있고, 삽입 삭제가 적으며 검색을 필요로한다면 배열이 유리하다.

ps : 배열은 메모리가 연속적이어서 주소값을 일정한 크기로 더해주며 검색하기 때문에 속도가 비교적 빠르다.
반면 링크드리스트는 불연속적이어서 다음 공간을 찾아가는데까지 시간이 더 소요된다.


▶ 리스트의 예 
문자형 데이터가 저장될때
문자열이 차례로 저장될때
행렬
다항식


▶ 리스트 추상 자료형 
리스트 생성 createList() -> 배열리스트인 경우에만 최대 원소 개수인 n을 지정해줘야함.
리스트 삭제 deleteList()
원소 추가 가능 여부판단 isFull() -> 이것도 배열리스트인 경우에만 의미가 있을 것임.
원소 추가 addElement()
원소 제거 removeElement()
리스트 초기화 clearList()
원소 개수 getListLength()
원소 반환 getElement()


▶ 배열리스트의 단점 
원소의 개수가 10만개인 배열리스트에서 원소의 추가/제거가 빈번하다면? 
-> 각 원소의 추가/제거 마다 10만개 - 1개 만큼의 원소이동이 계속해서 발생한다.
-> 성능이 좋지않음.


▶ 배열리스트 구현 
ArrayList 소스코드 확인.
ArrayList * 형을 사용하는 이유는 아마 메소드마다 배열리스트 구조체를 넘겨줘야하기 때문에, 포인터형으로 만든것 같다.
(call by reference)★★★

