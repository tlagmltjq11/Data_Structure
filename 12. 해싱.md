## 해싱

![해싱2](https://user-images.githubusercontent.com/43705434/113192951-5c887e00-929a-11eb-80bd-953190f42b3d.PNG)<br>
<br>

지금까지 배운 선형 탐색이나 이진 탐색은 모두 저장된 키값과 반복저으로 비교함으로써 탐색하고자 하는 항목에 접근했다.<br>
이러한 방법들은 최대 가능한 시간 복잡도가 **O(logn)** 에 그친다. 이 정도로도 괜찮을 수 있지만 어떠한 분야에서는 <br>
더 빠른 탐색 알고리즘을 요구하기 때문에 해싱을 배워본다. 지금부터 배울 해싱은 **O(1)** 의 시간안에 탐색을 끝마칠 수 있는 기법이다.<br>
<br>

해싱은 key에 산술적인 연산을 적용하여 항목이 저장되어 있는 테이블의 주소를 계산하고 이를 통해 항목에 접근한다.<br>
이렇게 키에 대한 연산에 의해 접근이 가능한 구조를 **해시 테이블** 이라 부른다. 또한 해시 테이블을 이용한 탐색을 <br>
**해싱** 이라 하는 것이다.<br>
<br>

이러한 해싱은 심볼 테이블, 철자 검사기, 특히 데이터베이스에서 유용하게 사용된다.<br>
<br>
<br>

## 추상 자료형

![딕셔너리구조](https://user-images.githubusercontent.com/43705434/113192946-5befe780-929a-11eb-860c-71034e9e394b.PNG)<br>
<br>

해싱은 보통 Dictionary 자료 구조를 구현할 때 최상의 선택이 된다.<br>
그렇기에 먼저 추상 자료형 '사전'에 대하여 살펴본다.<br>
<br>

✔️ **Dictionary** 는 **Hash map** 혹은 **Hash table** 이라고도 불리우며 **(키, 값)** 쌍을 요소로 갖는 자료구조이다.<br>
key : 사전의 단어처럼 항목을 구별시키는 것.<br>
value : 단어의 설명에 해당한다.<br>
<br>

이러한 사전은 오직 키에 의해서만 관리되기 때문에 키에 따라 정렬되어 있기도 그렇지 않기도 하다.<br>
**사전에서는 무조건 키에 의해 항목에 접근할 수 있으면 된다. 고로 정렬 여부는 부가적인 옵션이다.** <br>
<br>

객체 : 일련의 (key, value) 쌍의 집합<br>
연산 : <br>
add(key, value) : 사전에 추가한다.<br>
delete(key) : key에 해당하는 요소를 찾아서 삭제한다.<br>
search(key) : key에 해당하는 요소를 반환한다.<br>
<br>
<br>

## 해싱의 구조

![해싱](https://user-images.githubusercontent.com/43705434/113192948-5c887e00-929a-11eb-8677-e64ce725a2d3.PNG)<br>
해싱의 기본적인 아이디어는 간단하다. 만약 어떤 회사의 직원이 100명이라고 할때 100명의 직원들은 0~99까지의 아이디를 부여받는다.<br> 
이때 단순히 크기가 100인 배열을 만들고 직원의 아이디를 배열의 인덱스로써 사용하면 직원의 정보에 O(1) 만에 접근할 수 있는 것이다.<br>
즉 **해싱** 이란 어떤 항목의 키만을 가지고 바로 항목이 들어있는 배열의 인덱스를 결정하는 기법이다. **해시 함수** 가 키를 입력받아<br>
**해시 주소** 를 생성하고 이 해시주소를 **해시 테이블** 의 인덱스로 사용하는 것이다.<br>
<br>

하지만 현실적으로는 key들이 문자열이거나 매우 큰 숫자이기 때문에 탐색 키를 배열의 인덱스로 직접 사용하기에는<br>
무리가 있다. 고로 **각 탐색 키를 작은 정수로 사상(해싱) 시키는 특정 함수가 필요하다.** <br>
<br>
<br>

✔️ **이상 vs 현실**<br>

![이상해싱](https://user-images.githubusercontent.com/43705434/113192942-5b575100-929a-11eb-93c8-02e2357d3be2.PNG)<br>
이상적인 해싱의 경우는 대학생들의 학번을 key로 두고 인적사항을 해싱으로 저장하는 경우로 들자.<br>
각 학생들의 고유한 학번의 맨뒤 3자리 숫자만 추출해서 인덱스로 사용한다. 그렇게되면 해싱 테이블은<br>
1000개의 공간만 유지하면서 모든 학생들의 인적사항을 저장하고 탐색과 연산이 **O(1)** 만에 이루어진다.<br>
<br>
<br>

![현실해싱충돌](https://user-images.githubusercontent.com/43705434/113192940-5abeba80-929a-11eb-88bb-c54a844211f2.PNG)<br>
![현실해싱오버플로우](https://user-images.githubusercontent.com/43705434/113192934-5a262400-929a-11eb-9235-2e1fdf228f7a.PNG)<br>
하지만 현실은 키는 매우많고 해시테이블의 크기는 상당한 제약을 받기 때문에 1 : 1로 공간을 할당해 줄 수가 없다.<br>
따라서 해시 테이블의 크기가 key에 비해 작은것이 사실이다. 또한 key중 일부만 사용하기 때문에 전체를 위한 공간을<br>
항상 준비할 필요도 없다. 따라서 더 작은 해시 테이블을 사용하는 해시함수를 고안해본다.<br>
간단하면서도 명료한 방식은 키를 해시테이블의 크기로 나누어서 그 나머지를 해시 테이블의 주소로 하는 것이다.<br>
나머지를 취하면 0~M-1 까지의 숫자가 생성된다. 이 값은 유효한 인덱스가 된다. 하지만 충돌이 필연적으로 일어나게 될 것이다.<br>
만약 한 버킷에 여러 슬롯을 할당한다고 할지라도 충돌에 대한 대응책이 없다면 결국 오버플로우로 이어지게 될 것이다.<br>
따라서 실제의 해싱에서는 충돌과 오버플로우가 빈번하기 때문에 이들을 처리하거나 구조 변경이 이루어져 <br>
시간 복잡도는 이상적인 **O(1)** 보다 떨어지게 된다.<br>
<br>
<br>

✔️ **해시테이블**<br>

![해시테이블구조](https://user-images.githubusercontent.com/43705434/113192943-5b575100-929a-11eb-82b4-1f736aec62d2.PNG)<br>
해시테이블은 m개의 버킷으로 이루어져 m개의 원소를 갖는다.<br>
또한 이러한 버킷들은 각각 s개의 슬롯을 가질 수 있다. 하나의 슬롯에는 하나의 항목이 저장된다.<br>
이렇게 하나의 버킷에 **여러개의 슬롯을 두는 이유는 서로 다른 두 키가 해시함수에 의해 동일한 해시주소를<br>
할당 받을 수 있기 때문이다.**<br>
<br>
<br>

✔️ **충돌**<br>

![해싱충돌](https://user-images.githubusercontent.com/43705434/113192944-5befe780-929a-11eb-8847-882e9963db22.PNG)<br>
앞서 설명했듯이 서로 다른 두 개의 키가 해시함수에 의해 동일한 해시주소를 할당받는 경우를 **충돌** 이라 한다.<br>
충돌이 일어나게되면 같은 버킷의 다른 슬롯에 저장하게되는데 충돌이 자주 일어난다면 버킷 내부에서의 순차 탐색 시간이<br>
길어지기 때문에 성능이 저하될 수 있으므로 해시 함수를 수정하거나 해시테이블의 크기를 적절히 조절해 주어야 한다.<br>
<br>
<br>

✔️ **오버플로우**<br>
만약 충돌이 버킷에 할당된 슬롯의 수 보다 많이 발생하게 되면 버킷에 더 이상 항목을 저장할 수 없게되는 **오버플로우** 가 발생한다.<br>
오버플로우가 발생하면 저장이 불가하기에 해결 방법이 반드시 필요하다. 해당 방법들을 뒤에서 살펴보겠다.<br>
<br>
<br>

## 해시 함수
해시 함수란 KEY값을 해시 테이블의 주소로, 즉 특정 범위내의 정수값으로 사상 시켜주는 함수를 의미한다.<br>
좋은 해시 함수의 조건은 다음과 같다.<br>
1. 충돌이 적어야 한다.
2. 값이 테이블 내에서 고르게 분포되어야 한다.
3. 계산이 빨라야 한다.
<br>

조건 2번 같은 경우는 예를 들어 영문으로 되어 있는 은행 지점명의 첫 번째 글자를 취해 해시함수로 사용하는 것은 옳지 않다.<br>
x로 시작하는 은행은 없기 때문이다. 고로 고르게 분포될 수 있는 방식을 채택해야 한다.<br>
<br>

✔️ **제산 함수**<br>
제산함수는 나머지 연산자(mod)를 사용해 key를 해시 테이블의 크기로 나눈 나머지를 해시 주소로 사용하는 방법이다.<br>
> h(k) = k mod M
<br>

해시 함수의 값의 범위는 0 ~ M-1이 되기 때문에 해시 테이블의 인덱스로 사용하기에는 이상적인 값이 된다.<br>
하지만 이때 **해시 테이블의 크기인 M은 주로 소수 ( prime number )** 로 선택해야 한다.<br>
이는 해시 주소를 상당히 고르게 분포시켜주기 때문인데 그 이유를 파헤쳐보겠다. M이 짝수라면 나머지도 짝수이고<br>
홀수라면 나머지도 홀수이게 된다. 만약 메모리 주소를 가지고 해싱을 한다면 k가 짝수가 될 가능성이 높다.<br>
이유는 메모리 주소가 보통 2의 배수이기 때문이다. 이런식으로 해시 주소가 한쪽으로 편향되는 것은 좋지 않다.<br>
그렇기에 M은 홀수여야 하는데 만약 M이 소수라면 더욱 골고루 값을 만들어낼 수 있다.<br>
**만약 나머지 연산을 수행했을 때 음수가 나올 가능성에도 대비해야 한다. 따라서 음수라면 M을 더해서 결과값이<br>
항상 0 ~ M-1에 속하게 해야한다.** <br>
<br>
<br>

✔️ **폴딩 함수**<br>

![폴딩함수](https://user-images.githubusercontent.com/43705434/113192957-5e524180-929a-11eb-9db3-629fb89e7dfa.PNG)<br>
폴딩 함수는 주로 **key가 해시 테이블의 크기보다 더 큰 정수일 경우** 에 사용된다. 예를들어 key는 32비트이고<br>
해시 테이블의 인덱스는 16비트인 경우다. 이런 경우, 키의 앞의 16비트를 무시하고 뒤 16비트만 사용하게 된다면<br>
충돌이 쉽게 발생할 것이다. 고로 키를 16비트로 2부분으로 나누고 해당 값들을 비트별로 XOR 연산하여 주소를 계산한다.<br>
**즉 폴딩 함수는 키를 여러 부분으로 접어 모두 더한 값을 해시 주소로 사용한다.** **이동폴딩, 경계폴딩** 이 대표적인데<br>
이동폴딩은 키를 여러 부분으로 나눈 값을 더해 주소로 사용하고, 경계폴딩은 키의 이웃한 부분을 거꾸로 더하여 주소를 얻는다.<br>
<br>
<br>

✔️ **중간 제곱 함수**<br>
중간 제곱 함수는 키를 제곱한 다음 중간의 몇 비트를 취해서 주소를 생성한다.<br>
<br>
<br>

✔️ **비트 추출 방법**<br>
해시 테이블의 크기가 M = 2^k 일 때 키를 이진수로 간주하여 임의의 위치의 k개의 비트를 해시 주소로 사용하는 것이다.<br>
하지만 키의 일부 정보만을 사용하므로 집중 현상이 일어날 수 있다.<br>
<br>
<br>

✔️ **숫자 분석 방법**<br>
숫자로 구성된 키에서 각 위치에 잇는 **수의 특징을 미리 알고 있을 때** 사용하는 방식이다.<br>
예를 들어 학번이 20210401이라면 입학년도를 의미하는 앞의 4자리는 편중되어 있으므로 가급적 <br>
사용하지 않고 나머지 수를 조합해 주소로 사용하는 것이다.<br>
<br>
<br>

✔️ **탐색키가 문자열일 경우 주의할 점**<br>
키들이 정수일 때는 비교적 쉽게 해시 주소로 변환할 수 있다. 그러나 많은 경우 키들이 문자열일 수 있다.<br>
따라서 문자열로부터 좋은 해시 주소를 생성하는 것이 중요하다. 대부분 문자를 아스키 코드값으로 변환해<br>
모두 더한 값을 key로 쓰곤 하는데 이 방식은 'cup' 과 'puc'을 구별할 수 없다.<br>
**더 좋은 방법은 글자들의 아스키 코드 값에 위치에 기초한 값을 곱하는 것이다.**<br>
즉 문자열 s가 n개의 문자를 갖고 있다고 가정하고 s안의 i번째 문자가 ui라고 하면 해시 주소를 다음과 같이 계산한다.<br>
> u0 * g^n-1 + u1 * g^n-2 + u2 * g^n-3 ...
<br>

**이 방법은 키가 긴 문자열일 경우 오버플로우를 일으킬 수 있다. 고로 음수가 되는 경우를 처리해주어야 한다.** <br>
<br>
<br>

## 오버플로우 해결책
오버플로우가 발생하면 더 이상 해시테이블에 저장하는 것이 불가능하다. 따라서 효과적으로 이를 해결해야 한다.<br>
우리는 2가지의 해결책을 생각할 수 있다.<br>
1. 개방 주소법 : 충돌이 일어난 항목을 다른 위치에 저장한다.
2. 체이닝 : 해시테이블의 하나의 버킷에 여러 개의 항목을 저장할 수 있도록 구조를 변경한다.
<br>

## 개방 주소법
개방 주소법은 특정 버킷에서 충돌이 발생하면, 비어있는 버킷을 찾는 방법이다. 이 비어있는 버킷에 항목을 저장한다.<br>
해시테이블에서 비어있는 공간을 찾는 것을 조사라고 한다.<br>
<br>

✔️ 장점 :<br>
1) 또 다른 저장공간 없이 해시테이블 내에서 데이터 저장 및 처리가 가능하다.<br>
2) 또 다른 저장공간에서의 추가적인 작업이 없다.<br>
<br>

✔️ 단점 :<br>
1) 해시 함수(Hash Function)의 성능에 전체 해시테이블의 성능이 좌지우지된다.<br>
2) 데이터의 길이가 늘어나면 그에 해당하는 저장소를 마련해 두어야 한다.<br>
<br>

✔️ **선형 조사법**<br>
선형 조사법은 만약 **ht[k]** 에서 충돌이 발생했다면 **ht[k+1]** 이 비어있는지를 살펴본다.<br>
만약 비어있지 않다면 **ht[k+2]** 를 살펴본다. 이런식으로 **비어있는 공간이 나올 때까지** 조사하는 방법이다.<br>
만약 테이블의 끝에 도달하면 다시 처음부터 조사하며, 처음 조사를 시작했던 곳으로 되돌아오게 되면<br>
테이블이 가득 찬 것으로 판단한다.<br>
<br>

비교적 간단한 이 방법은 한번 충돌이 시작되면 그 위치에 항목들이 집중되는 **군집화** 현상이 일어날 수 있다.<br>
최악의 경우에는 집중된 항목들이 결합하는 현상까지 발생하므로 탐색 시간이 길어지는 단점이 있다.<br>
**즉 간단하지만 오버플로우가 자주 발생하면 집중과 결합에 의해 탐색의 효율이 크게 저하되는 방식이다.**<br>
<br>
<br>

✔️ **이차 조사법**<br>
이차 조사법은 선형 조사법과 유사하지만 다음 조사할 위치를 다음 식에 의해 결정한다.<br>
> (h(k) + inc * inc) mod M for inc = 0, 1, .... M-1
<br>

여기서 주의할 점은 모든 위치를 조사하게 만들려면 여전히 M은 소수여야 한다는 점이다.<br>
**이 조사법은 선형 조사법의 문제인 집중과 결함을 크게 완화시킬 수 있다.**<br>
다만 이 방법도 **2차 집중 문제** 를 일으킬 수 있지만 심각한것은 아니다.<br>
**2차 집중의 이유는 동일한 위치로 사상되는 여러 키들이 같은 순서에 의하여 빈 버킷을 조사하기 때문이다.**<br>
이것은 아래 이중 해싱법으로 해결할 수 있다.<br>
<br>
<br>

✔️ **이중 해싱법**<br>
**이중 해싱법은 오버플로우가 발생함에 따라 항목을 저장할 다음 위치를 결정할 때, 원래 해시 함수와 다른 별개의 해시 함수를 이용하는 방법이다.**<br>
이 방법은 항목들을 보다 균일하게 분포시킬 수 있으므로 효과적인 방법이다. 선형조사법과 이차조사법은 충돌이 발생했을 시<br>
어떤 값을 더해서 다음 위치를 얻는다. 선형조사법은 +1을 이차조사법은 inc * inc가 된다.<br>
따라서 해시 함수값이 같으면 차후에 조사되는 위치도 같게 된다. **하지만 이중 해싱법은 키를 참조하여 더해지는 값을 결정하기 때문에<br>
해시 함수값이 같더라도 키가 다르면 서로 다른 조사 순서를 갖는다. 고로 이차집중을 피할 수 있다.**<br>
두 번째 해시함수는 조사 간격을 결정한다.<br>
<br>
<br>

## 체이닝

![체이닝](https://user-images.githubusercontent.com/43705434/113192950-5c887e00-929a-11eb-9f09-5867209cfad1.PNG)<br>
**선형 조사법이 탐색 시간이 많이 걸리는 이유는 충돌 때문에 헤시 주소가 다른 키하고도 비교를 해야 하는데 있다.<br>
만약 해시 주소가 같은 키만을 하나의 리스트로 묶어둔다면 불필요한 비교는 하지 않아도 될 것이다.**<br>
리스트는 그 크기를 예측할 수 없으므로 연걸리스트로 구현해야 할 것이다.<br>
<br>

체이닝은 이러한 방식에 고안해 **해시 테이블의 구조를 각 버킷이 하나 이상의 값을 저장할 수 있도록 연결리스트로 구성** 했다.<br>
**( BST와 같은 다른 자료구조를 이용해서 체이닝을 구현하기도 한다. )**<br>
물론 버킷 내에서 원하는 항목을 찾기 위해서는 연결리스트를 순차탐색 한다.<br>
<br>

테이블에 데이터를 삽입할때에는 각 key에 해당하는 해시주소값으로 특정 버킷 연결리스트를 찾아간 후 새로운 노드를 동적생성해<br>
데이터를 노드에 복사하고 노드를 연결리스트에 연결해주면 된다.<br>
<br>

✔️ 장점<br>
**체이닝은 해시테이블을 연결리스트로 구성하므로 필요한 만큼의 메모리만 사용하게 되어 공간적 사용 효율이 매우 우수하다.<br>
또한 오버플로우가 발생할 경우에도 해당 버킷의 연결리스트만 처리하게 되므로 수행 시간 면에서도 매우 효율적인 방식이다.**<br>
<br>

✔️ 단점<br>
**하지만 데이터의 수가 많아지면 동일한 버킷에 chaining되는 데이터가 많아지며 그에 따라 캐시의 효율성이 감소한다는 단점이 있다.<br>
또한 외부 저장 공간 작업을 추가로 해야 한다.**<br>
<br>

## 해싱 분석

![해싱복잡도](https://user-images.githubusercontent.com/43705434/113192955-5db9ab00-929a-11eb-817d-bdced7bf929c.PNG)<br>
<br>

✔️ **시간복잡도**<br>
각각의 Key값은 해시함수에 의해 고유한 index를 가지게 되어 바로 접근할 수 있으므로 평균 **O(1)** 의 시간복잡도로 데이터를 조회할 수 있다.<br>
하지만 데이터의 충돌이 발생한 경우 Chaining에 연결된 리스트들까지 검색을 해야 하므로 **O(N)** 까지 시간복잡도가 증가할 수 있다.<br>
<br>

✔️ **해싱의 장단점**<br>
단점<br>
순서가 있는 배열에는 어울리지 않는다.<br>
: 상하관계가 있거나, 순서가 중요한 데이터의 경우 Hash Table은 어울리지 않다. 순서와 상관없이 key만을 가지고 hash를 찾아 저장하기 때문이다.<br>

공간 효율성이 떨어진다.<br>
: 데이터가 저장되기 전에 미리 저장공간을 확보해 놓아야 한다. 공간이 부족하거나 아예 채워지지 않은 경우가 생길 가능성이 있다.<br>

Hash Function의 의존도가 높다.<br>
: 평균 데이터 처리의 시간복잡도는 O(1)이지만, 이는 해시 함수의 연산을 고려하지 않는 결과이다. 해시함수가 매우 복잡하다면 해시테이블의 모든 연산의 시간 효율성은 증가할 것이다.<br>
<br>

장점<br>
해시 테이블은 키를 가지고 빠르게 value에 접근하고 조작할 수 있는 장점이 있어서 많이 사용된다.<br>
<br>

## 해싱의 응용 분야
해싱은 방대한 양의 데이터에 액세스해야하는 상황에서 널리 사용된다.<br>

1. 해싱은 데이터베이스의 인덱싱에 사용된다. 데이터가 파일에서 추출되어야 할 때, 탐색키는 먼저 인덱스 파일에서<br>
검색되고, 검색 결과로부터 데이터베이스의 파일에서의 정확한 위치를 알 수 있다. 인덱스 파일의 키 정보는 종종 해시 테이블로 구현된다.<br>

2. 컴파일러에서 심볼테이블을 구현하는데 사용된다. 사용자가 정의한 식별자의 기록을 유지하기 위해 심볼 테이블을 사용하는데<br>
이때 해싱을 사용하여 변수의 이름이나 함수의 이름을 빠르게 찾을 수 있다.

3. 인터넷 검색 엔진에서 널리 사용된다.
<br>




