## 스택이란<br>
한 쪽 끝에서만 자료를 넣고 뺄 수 있는 LIFO(Last In First Out) 형식의 자료 구조이다.<br>
데이터들이 입력의 역순으로 빠져나오는 특성을 이용해 undo, 뒤로가기 등의 기능구현에 도움을 줄 수 있다.<br>

![stack](https://user-images.githubusercontent.com/43705434/108394198-ce12ec80-7257-11eb-9858-fb07bf454a58.png)

또한 메모리의 활성레코드(함수 호출시) 영역에서 복귀할 주소를 기억하는데 사용되기도 한다.<br>
<br>

## 추상 자료형<br>
객체 : 선형리스트의 일종으로 정의됨.

연산 :<br>
create(size) : 최대 크기가 size인 공백 스택 생성<br>
isFull : 스택이 가득 차있는지 반환<br>
isEmpty : 스택이 비어있는지 반환<br>
push : 스택의 맨 위에 데이터 추가<br>
pop : 스택의 맨 위 데이터를 제거하며 반환<br>
peek : 스택의 맨 위 데이터를 제거하지않고 반환<br>
<br>

## 구현 방식<br>
배열 vs 연결리스트<br>
배열을 이용해서 스택을 구현하면 간단하고 성능이 우수하며 단순한 반면 크기가 고정적이게 된다.<br>
반면 연결리스트를 이용해서 구현하면 복잡하지만 가변적인 크기를 가질 수 있다.<br>

tip.
* 스택의 가장 맨위에 존재하는 데이터를 가르킬 top 변수가 필요하다. (스택이 비어있다면 -1값)<br>
* 만약 스택에 저장되어야 하는 값이 복잡한 구조라면, 구조체를 저장하면 될 일.<br>
* 또한 stack 배열과 top 변수를 구조체로 묶어서 사용하며, 해당 구조체의 포인터를 각 메소드에<br>
넘겨주는 방식이 효율적이다.<br>

```c
typedef struct
{
	int data[스택사이즈];
	int top;
}Stack;
```

* 만약 스택의 사이즈가 런타임에 결정되어야 한다면, 동적할당을 통해 스택을 생성하고 스택이 가득찬다면<br>
realloc을 통해서 스택의 사이즈를 늘려가며 사용할 수 있을 것이다.<br>
<br>

**링크드리스트 방식을 이용해서 구현한 Stack 코드를 추가함.**<br>
* 각 데이터를 링크드리스트와 유사하게 Node 방식으로 저장하며, 포인터로 이어준다.<br>
* Stack 구조체는 top 포인터를 가져야한다. 해당 top 포인터를 통해 노드의 삽입, 삭제를 모두 처리하면 된다.(LIFO)<br>
* Node를 동적할당으로 생성해 포인터를 이어주기만 하면 되기 때문에, size가 무한하다.<br>
<br>

## 스택의 응용 <br>

1. 괄호검사	Stack_CheckBracket.c 참조★<br>
컴파일러가 코드의 괄호 사용을 검사할때 스택을 이용할 수 있다.<br>
<br>

괄호의 조건
* 왼쪽 괄호와 오른쪽 괄호는 갯수가 같아야 한다.
* 같은 종류의 왼쪽 괄호는 오른쪽 괄호보다 먼저 나와야 한다.
* 서로 다른 종류의 왼쪽 괄호와 오른쪽 괄호 쌍은 서로 교차하면 안 된다.

풀이법<br>
코드에서 왼쪽 괄호를 만나면 계속해서 스택에 Push 하다가 오른쪽 괄호를 발견하면<br>
스택에서 가장 최근의 왼쪽 괄호를 Pop을 통해 꺼내 둘의 타입을 맞춰보면 된다.<br>
-> 가장 마지막에 삽입된 왼쪽 괄호가 가장 먼저 닫혀야하기 때문에 오른쪽 괄호를 만날 경우<br>
스택의 후입선출 특성을 이용해 왼쪽 괄호와 검사하는 방식이다. ★<br>

2. 후위표기식 계산		Stack_PostFix.c 참조★<br>
컴파일러는 인간이 타이핑한 중위표기법을 후위표기법으로 바꾸어 계산을 하는데 이 후위표기식을<br>
계산할때 스택을 사용할 수 있다.<br>

후위표기식의 장점
* 식 자체에 우선순위가 표현되어있어 괄호가 필요 없다.
* 수식을 읽으면서 바로 계산이 가능하다.

풀이법<br>
수식을 스캔하여 피연산자이면 스택에 저장하고 연산자이면 스택에서 피연산자를 꺼내어 연산 후<br>
결과를 다시 스택에 저장한다.<br>

ex)  8 / 2 - 3 	-> &nbsp;&nbsp;&nbsp;&nbsp;	82/3-  (후위표기식)<br>

*<br>
8 2 / 3 - &nbsp;&nbsp;&nbsp;&nbsp;		스택 8<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp; *<br>
8 2 / 3 - &nbsp;&nbsp;&nbsp;&nbsp;		스택 8 2<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *<br>
8 2 / 3 - &nbsp;&nbsp;&nbsp;&nbsp;		스택 4<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *<br>
8 2 / 3 - &nbsp;&nbsp;&nbsp;&nbsp;		스택 4 3<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *<br>
8 2 / 3 - &nbsp;&nbsp;&nbsp;&nbsp;		스택 1<br>
<br>
최종 결과  = 1<br>
<br>

3. 미로찾기	Stack_Maze.c 참조★<br>
미로를 탈출할때 하나의 경로를 선택해 시도해보고 안되면 다른 경로를 시도해야 한다.<br>
이때 다른 경로들이 어딘가에 저장되어 있어야 하는데, 현재 위치에서 가능한 경로 중에서 가장 가까운<br>
경로를 저장할 수 있는, 즉 최근에 저장한 경로가 쉽게 추출되는 자료구조를 이용하면 될 것이다.<br>
그 중 하나가 스택이다.<br>

풀이법<br>
현재 위치에서 갈 수 있는 경로의 좌표들을 스택에 저장했다가, 막다른 길을 만나면 아직 방문하지 않은<br>
경로 중에서 가장 가까운 경로로 다시 돌아가 새로운 경로를 찾아보게끔 하면 된다.<br>
