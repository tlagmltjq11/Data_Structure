## 우선순위 큐

![우선순위그림](https://user-images.githubusercontent.com/43705434/111613184-9761cf00-8821-11eb-881f-17e273ae42d5.PNG)<br>
<br>

일반적인 큐(Queue)는 First in-First Out 구조입이다. 즉, 어떤 부가적인 조건 없이 먼저 들어온 데이터가 먼저 나가는 구조였다.<br>
하지만 우선순위 큐(Priority Queue)는 들어간 순서에 상관없이 우선순위가 높은 데이터가 먼저 나오는 것 것을 말한다.<br>
이러한 우선순위 큐는 힙(Heap)이라는 자료구조를 가지고 구현하기 때문에 이 둘을 묶어서 설명하겠다.<br>

> 사실 일반적인 큐로도 볼 수 있는 것이, 스택이나 큐로도 우선순위 큐를 얼마든지 구현할 수 있기 때문이다.<br>
<br>

![우선순위큐란](https://user-images.githubusercontent.com/43705434/111613187-97fa6580-8821-11eb-987b-403138fb0e10.PNG)<br>
<br>

**사용 분야**<br>
네트워크 트래픽 제어 : 네트워크에서 네트워크 관리와 관련된 패킷을 우선으로 처리..<br>
OS 작업 스케줄링 : 운영체제에서 프로세스중 시스템 프로세스를 우선으로 처리..<br>
<br>

## 우선순위 큐 구현 방식

1. 배열로 구현<br>
<br>

**정렬이 되어 있지 않은 배열을 사용하는 경우**<br>
삽입 : 아주 간단하게 배열의 맨 끝에 요소를 추가하면 된다. **O(1)**<br>
삭제 : 가장 우선순위가 높은 요소를 찾아야 하므로 모든 요소를 순회해야 한다. **O(n)**<br>
<br>

**정렬이 되어 있는 배열을 사용하는 경우**<br>
삽입 : 기존 요소들과 비교하여 적절한 위치를 찾아서 삽입해야 하며, 기존 요소들을 이동시켜 빈자리를 만들어야 한다. **O(n)**<br>
삭제 : 최소냐 최대냐에 따라 다르겠지만, 최대라면 맨뒤에 자리하는 요소를 바로 반환하면 된다. **O(1)**<br>
<br>

2. 연결리스트로 구현<br>
<br>

**정렬이 되어 있지 않은 연결리스트를 사용하는 경우**<br>
삽입 : 최대한 연산을 줄이기위해 첫 번째 노드로 삽입시키는 것이 유리하다. **O(1)**<br>
삭제 : 모든 노드들을 순회해서 우선순위가 가장 높은 요소를 반환해야한다. **O(n)**<br>
<br>

**정렬이 되어 있는 연결리스트를 사용하는 경우**<br>
삽입 : 모든 노드를 순회하며 삽입 위치를 찾아야 한다. **O(n)**<br>
삭제 : 우선순위가 높은 요소를 첫 번째 노드로 유지시켜야 연산이 가장 적다. **O(1)**<br>
<br>

**특징**<br>
배열방식과 달리 삽입, 삭제 시 요소들을 밀고 당겨주지 않아도 된다.<br>
배열방식보다 순회가 느리다.<br>
<br>

3. 히프로 구현<br>
![우선순위큐삽입삭제복잡도비교](https://user-images.githubusercontent.com/43705434/111613182-9761cf00-8821-11eb-8cda-8d2e1741a7f5.PNG)<br>

히프의 특징과 느슨한 정렬 상태를 이용해서 우선순위 큐를 구현하게 되면 삽입, 삭제 모두 **O(nlogn)** 으로 처리 가능하다.<br> 
O(n)과 O(nlogn)의 차이에 주목해야하는데, 만약 n이 1000인 경우 1000초 vs 10초 의 유의미한 결과를 보여준다.<br>
<br>

**결론**<br>
우선순위 큐를 구현하는데 있어서, Heap을 이용하는 것이 가장 효율적이며 힙은 그 자체가 우선순위 큐에 부합하는 자료구조라고
설명할 수 있다.<br>
<br>

## 우선순위 큐 추상자료형
Create() : 큐 생성<br>
Init(q) : 초기화<br>
Insert(q, x) : 큐에 요소 추가<br>
Delete(q) : 큐에서 우선순위가 가장 높은 요소 반환 후 삭제<br>
Find(q) : 큐에서 우선순위가 가장 높은 요소 반환<br>
IsEmpty(q) : 비어있는지 확인<br> 
IsFull(q) : 포화 상태인지 확인<br>
<br>

## 히프

![최대최소힙](https://user-images.githubusercontent.com/43705434/111613185-97fa6580-8821-11eb-8a81-5c7e1d9d1be4.PNG)<br>
<br>

히프는 완전 이진 트리의 일종으로 우선순위 큐를 위해 특별히 만들어진 자료구조라고 봐도 무방하다.<br>
항상 루트에 우선순위가 가장 높은 요소가 존재하기 때문에 그 값을 추출만 하면 되기 때문이다.<br>

이러한 히프는 느슨한 정렬 즉 완전히 정렬되진 않았지만, 그렇다고 전혀 정렬이 안된것도 아닌 상태를 유지한다.<br>
> 상위 노드가 자식 노드들의 우선순위보다 크거나 같은 형태로 트리구조를 이루고 있기 때문이다.
> 큰 값이 위에있고, 작은 값이 아래있기 때문에 어느정도 정렬이 되어지는 상태.
<br>

**히프의 특징**<br>
1. 히프는 여러 개의 값들 중에서 가장 큰 값이나 가장 작은 값을 빠르게 찾아내도록 만들어진 자료구조이다.<br>
2. 최대 힙, 최소 힙이 존재하는데 최대 힙은 루트 노드로 올라갈수록 저장된 값이 커지는 구조, 최소 힙은 그 반대이다.<br>
3. BST와 달리 중복값을 허용한다.<br>
<br>

## 히프의 구현
히프를 구현하는 방식 역시도 배열 vs 연결리스트로 나뉘게 되지만, 히프의 특성 상 새로운 원소를 항상 **마지막 위치**에 추가해야<br>
하기 때문에, 연결리스트를 사용하는 방식은 비효율적이다. 고로 **배열** 을 이용해서 힙을 구현하는 것이 대부분이다.<br>
앞서 트리에서 배웠듯이, 힙 역시 완전 이진 트리이기 때문에 각 노드에 번호를 부여하고 해당 번호를 배열의 인덱스로 생각하여<br>
요소들을 저장하면 된다.<br>
<br>
<br>

![배열힙인덱스팁](https://user-images.githubusercontent.com/43705434/111613181-96c93880-8821-11eb-94fa-d144935ac590.PNG)<br>
<br>
**위 그림 설명.**<br>
1. 0번 인덱스는 사용하지 않는다.
2. 왼쪽 자식의 인덱스 = 부모 인덱스 * 2
3. 오른쪽 자식의 인덱스 = 부모 인덱스 * 2 + 1
4. 부모의 인덱스 = 자식의 인덱스 / 2
<br>
<br>
<br>

**삽입 연산 ★**<br>

![힙삽입](https://user-images.githubusercontent.com/43705434/111613175-9630a200-8821-11eb-8473-20db5aa79896.PNG)<br>
<br>

힙트리에 새로운 요소를 삽입하려는 경우 일단 새로운 노드를 히프의 마지막 노드로 즉 배열의 마지막 인덱스 + 1 위치에 삽입해야 한다.<br>
그 후 새로운 노드를 부모 노드들과 비교해서 부모보다 우선순위가 높다면 위로 상승시켜가는 동작을 반복하여 제 위치를 찾아주면 된다.<br>
이런식으로 진행해야 전체 힙트리의 형태를 무너뜨리지 않고 원활하게 삽입을 진행할 수 있다.<br>
<br>
<br>

**삭제 연산 ★**<br>

![힙삭제](https://user-images.githubusercontent.com/43705434/111613193-992b9280-8821-11eb-80f9-03c73f81d6f5.PNG)<br>
<br>

최대 히프를 예로 들자면, 삭제 연산은 최대값을 가진 요소를 삭제하는 것이다. 이때 최대값은 루트에 저장되어 있기 때문에<br>
루트노드를 반환 후 삭제해주면 된다. 그 후 루트가 사라지게 되므로 힙트리를 재구성해야 한다!<br>
재구성하는 과정은 우선 힙트리의 가장 맨뒤에 위치하는 요소를 루트로 끌어올리는 것이 첫번째 단계이다.<br>
그 후에는 삽입 연산과 유사하게, 자식 노드들과 우선순위를 비교해가며 낮다면 아래로 하강시켜가는 동작을 반복하여 제 위치를 찾으면 된다.<br>
삭제 연산 역시 이러한 방식으로 진행해야 힙트리의 전체 형태를 유지할 수 있다.<br>
<br>

**삽입, 삭제 팁**<br>
삽입 시 새 노드와, 삭제 시 루트에 올려둔 리프노드를 매번 비교시 마다 옮겨주지 않고 최종적으로 위치가 결정되었을때 옮겨주게 되면,<br>
이동 횟수를 즉 연산 횟수를 줄일 수 있다. 물론 비교 대상이 되는 부모노드 혹은 자식노드는 매 반복마다 이동해주어야 한다.<br>
<br>

## 히프의 복잡도 분석
삽입 시 최악의 경우 마지막 위치에 삽입된 새 노드가 루트노드까지 상승해야하는 경우가 생길 수 있다.<br>
이 말은 즉슨 트리의 높이만큼 비교 연산 및 이동 연산이 필요하다는 의미이다. 완전이진트리의 **높이는 logn** 이기 때문에<br>
삽입의 **시간 복잡도는 O(logn)** 이 된다.<br>
<br>

삭제 시 최악의 경우 루트로 올라갔던 리프노드가 다시 리프까지 하강해야하는 경우가 생길 수 있다.<br>
삽입과 마찬가지로 트리의 높이만큼 연산이 필요할 수 있기 때문에 삭제의 **시간 복잡도는 O(logn)** 이 된다.<br>
<br>

**결론**<br>
배열이나 연결리스트로 구현한 우선순위 큐보다 삽입, 삭제 연산의 시간 복잡도가 O(logn)로 우월하며 편차가 적기 때문에<br>
**우선순위 큐는 힙으로 구현하는 것이 가장 알맞다는 결론이 나온다.** <br>
<br>

## 힙 정렬

![힙정렬복잡도비교](https://user-images.githubusercontent.com/43705434/111613196-99c42900-8821-11eb-8cf0-d9911ce585cc.PNG)<br>
<br>

정렬해야할 데이터들을 모두 최대 히프에 삽입하고, 한 번에 하나씩 요소를 힙에서 삭제하며 꺼내어 배열의 뒤쪽부터 저장하게 되면,<br>
오름차순으로 정렬할 수 있게 된다. 이렇게 힙을 이용해서 정렬하는것이 힙정렬이다.<br>
**시간복잡도는 삽입 (logn x 데이터 n개) + 삭제 (logn x 데이터 n개)이므로 2nlong이 되고 O(nlogn)이 된다.** <br>
<br>

**Tip.**<br>
힙 정렬이 최대로 유용한 경우는 전체 자료를 정렬하는 것이 아니라 가장 큰 값 몇 개만 필요할 때이다.<br>
<br>

## 우선순위 큐,  응용
1. 머신스케줄링 (LPT 알고리즘 - 힙 응용 Heap_LPT.c 참고 ★)<br>
기계 m개, 작업 n개가 존재하며, 각 작업은 기계 사용시간이 다르다고 가정할 때 우리의 목표는 모든 기계를 동원해<br>
최소의 시간안에 모든 작업들을 끝내는 것이다. 이와 같이 머신 스케줄링을 처리할 때 우선순위 큐를 사용할 수 있다.<br>

![LPT결과](https://user-images.githubusercontent.com/43705434/111613191-992b9280-8821-11eb-92f1-02a5560604bc.PNG)<br>
<br>

방식 : LPT 알고리즘과 같이 가장 긴 작업을 우선적으로 기계에 할당한다. 이때 할당을 받을 기계들을 최소 히프에서 관리해야 한다.<br>
최소 힙에 각 기계들을 요소로 삽입하고, 작업을 할당할 때 할당받을 기계를 힙에서 선택하는데 이때 우선순위의 기준은 종료 시간이다.<br>
즉 가장 빨리 현재 진행중인 작업을 마칠 수 있는 기계를 뽑는 것이다. 당연히 작업을 할당받으면 종료 시간을 갱신 후 다시 힙에 삽입해야 한다.<br>
이렇게되면 특정 기계에 작업들이 몰리지않고 최대한 골고루 나누어 줄 수 있기 때문에, 효율적인 스케줄링이 가능하다.<br>
즉 기계들의 종료시간을 우선순위로 힙에서 관리! <br>
<br>

2. 허프만 코드 (힙 응용 Heap_Huffman.c 참고 ★)<br>
허프만 코드는 데이터를 효율적으로 압축하는데 사용하는 그리디 알고리즘 중 하나이다.<br>
압축하고자 하는 문자열에서 빈도 수가 높은 문자는 짧은 비트로, 빈도 수가 낮은 문자는 긴 비트로 표현한다.(가변 길이 코드)<br>
즉, 문자의 빈도 수를 이용한다.<br>

![Huffman](https://user-images.githubusercontent.com/43705434/111613194-99c42900-8821-11eb-89a9-e19dab94b6b8.PNG)<br>
<br>

이때, 최소 힙을 이용해서 해결할 수 있다.<br>
<br>
